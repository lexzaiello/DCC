\documentclass{beamer}
\usepackage{fontspec}
\usepackage{ulem}
\usepackage{minted}
\usepackage[table]{xcolor}
\usepackage[
  backend=biber,
  style=alphabetic,
  sorting=ynt
]{biblatex}
\addbibresource{./refs.bib}

\AtBeginSection[]{
  \begin{frame}
    \vfill
    \centering
    \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
      \usebeamerfont{title}\insertsectionhead\par%
    \end{beamercolorbox}
    \vfill
  \end{frame}
}

\AtBeginSubsection[]
{
  \begin{frame}
    \vfill
    \centering
    \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
        \usebeamerfont{caption}\insertsectionhead\par%
        \vspace{0.5em}
        {\usebeamerfont{subtitle} \insertsubsectionhead}
    \end{beamercolorbox}
    \vfill
  \end{frame}
}

\setmainfont{DejaVu Serif} 
\setsansfont{DejaVu Sans}
\setmonofont{JuliaMono}[
    Scale=0.9,
    Extension = .ttf,
    UprightFont = *-Regular,
    BoldFont = *-Bold,
    ItalicFont = *-RegularItalic,
    BoldItalicFont = *-BoldItalic
]

\usemintedstyle{tango}
\newminted[leancode]{lean4}{
    mathescape=true,
    fontsize=\small
  }
\newcommand{\leane}[1]{\mintinline{lean4}|#1|}
\newcommand{\leanw}[1]{\texttt{#1}}
\newcommand{\dcce}[1]{\mintinline{lean4}[style=manni]|#1|}
\newcommand{\pie}[1]{\Pi_{#1}}
\newcommand{\type}[1]{\text{Type } #1}
\newcommand{\turnstile}{\vdash}
\newcommand{\sigl}[1]{\(\texttt{::[}#1\texttt{]}\)}
\newcommand{\sigle}[1]{\texttt{::[}#1\texttt{]}}

\usetheme{Madrid}

\title{Updates: Dependent Combinator Calculus}
\author{Alexandra Aiello}
\date{\today}

\begin{document}

\frame{\titlepage}

\begin{frame}{Distinct Iterations of the Calculus}
  \begin{figure}
  \resizebox{0.825\textwidth}{!}{%
  \begin{tabular}{ |p{0.1\textwidth}|p{0.23\textwidth}|p{0.23\textwidth}|p{0.23\textwidth}|p{0.2\textwidth}| }
    \hline
    Name & Main Feature & Meta Combinators?* & Uncurried Types? & Types are Well-Typed? \\
    \hline
    \(SKM\) & Reflection & Yes & No & No \\
    \hline
    \(SK\Pi\) & \(\Pi\) Combinator & Yes & No & No \\
    \hline
    \(SK\Gamma\) & \cellcolor{yellow!20}\((\Gamma, \Delta)\) registers & No & \cellcolor{yellow!20}Yes & Barely. Couldn't handle random edge cases. \\
    \hline
    List Calculus & \cellcolor{yellow!20}Extremely minimal kernel & No & Barely well-typed & Barely well-typed \\
    \hline
    Sigma interpretation & \cellcolor{yellow!20}Sigma type is data encoding \(\Pi\) & No & No & \cellcolor{yellow!20}Probably \\
    \hline
  \end{tabular}
}
\caption{*Meta combinators result in a huge tree. Each meta combinator has a type.}
\end{figure}
\end{frame}

\begin{frame}{The Ideal Dependent Combinator Calculus}
  \begin{itemize}
    \item Use \((\Gamma, \Delta)\) registers.
    \item Condense \(\pi\), \leane{next}, \leane{read} into one rule (equivalence proven \hyperlink{equivfst}{\beamergotobutton{here}}):
      \begin{itemize}
        \item Very small kernel
      \end{itemize}
    \item Pair interpretation: \(\Gamma[n]\) is a nested pair. Same eval rules as in \((\Gamma, \Delta)\), but a new well-typed meaning.
    \item \texttt{nil} combinator: downgrades a term to a type.
      \begin{itemize}
        \item Useful for arguments like \(\alpha : \type{n}\)
      \end{itemize}
    \item Core calculus is the typical \(SK\) combinators
  \end{itemize}
\end{frame}

\begin{frame}{Central Thesis: The Sigma-Curry Correspondence}
  \begin{itemize}
    \item Combinator types are much easier to form with all arguments in scope (``uncurried'')
    \item I demonstrate \hyperlink{equivsigmaapp}{\beamergotobutton{here}} that \texttt{Sigma.snd} projection is equivalent to function application
    \item Treating the future application as \textit{data} makes forming types much simpler
    \item We can capture projection of \texttt{fst}, \texttt{snd}, application, and many more with a single reduction rule
  \end{itemize}
\end{frame}

\begin{frame}{Ideal Inference Rule: Application}
  \begin{equation}
    \frac{
      \Gamma \vdash f : \sigle{\sigle{t_{in}, t_{out}}, \Delta},
      x : \alpha,
      (t_{in}\ \sigle{x, \delta}) \mapsto \alpha
    }{\Gamma \vdash (f\ x) : \sigle{t_{out}, \sigle{x, \Delta}}}
  \end{equation}
\end{frame}

\section{Research Questions: Sigma-Curry Correspondence}

\begin{frame}{Hypotheses: Sigma-Curry Correspondence}
  \begin{itemize}
    \item \sout{Should we internalize \(\pi\) projection in \sigl{a, b}, or should we have \sigl{fst, snd} combinators?} \textbf{Yes, internalize projection!}
      \begin{itemize}
        \item \sout{Can we derive \leane{fst}?} \textbf{Yes!}
        \item \sout{Can we derive \leane{snd}?} \textbf{Yes!}
        \item \sout{Can we fully emulate the old \(\pi\) combinator with a projector agrument?} \textbf{Yes!}
      \end{itemize}
    \item \sout{Can we derive application from \(\pi\) projection?} \textbf{Yes!}
    \item \sout{Can we derive \(S\) from both + \(\pi(id)\)?} \textbf{Yes!}
    \item \sout{Choose between \leane{fst} + \leane{snd} or \(\pi\) list projection combinator.} \textbf{Answered above.}
      \begin{itemize}
        \item \sout{Intuition says \leane{fst} and \leane{snd}, since they would have simpler types.} \textbf{Can derive \leane{snd} and \leane{fst}.}
      \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Research Questions AST}
  \begin{figure}
    \begin{leancode}
inductive Expr where
  | app : Expr → Expr → Expr
  | cons : Expr → Expr → Expr
  | π : Expr
  | fst : Expr | snd : Expr
  | both : Expr
  | const : Expr | const' : Expr
  | id : Expr | nil : Expr | ty : Expr

inductive IsStepStar { rel : Expr → Expr → Prop } : Expr → Expr → Prop
  | refl  : IsStepStar e e
  | trans : rel e₁ e₂
    → IsStepStar e₂ e₃
    → IsStepStar e₁ e₃
    \end{leancode}
    \caption{I have omitted universe levels for our research question proofs.}
  \end{figure}
\end{frame}

\subsection{\leanw{fst} and \leanw{snd} can be condensed into one rule}

\begin{frame}[fragile]{Single-Step Reduction for Projection Derivations}
  \begin{leancode}
inductive IsStep : Expr → Expr → Prop
  | sapp   : IsStep (.app ::[x, f], fn) (.app (.app fn f) x)
  | fst    : IsStep (\$ fst, _α, _β, fn, ::[x, f]) (\$ fn, x)
  | snd    : IsStep (\$ snd, _α, _β, fn, ::[x, f]) (\$ fn, f, x)
  | nil    : IsStep (\$ nil, α, x) α
  | id     : IsStep (\$ Expr.id, _α, x) x
  | const' : IsStep (\$ const', _α, _β, x, y) x
  | left   : IsStep f f'
    → IsStep (\$ f, x) (\$ f', x)
  | right  : IsStep x x'
    → IsStep (\$ f, x) (\$ f, x')
  \end{leancode}
\end{frame}

\begin{frame}[fragile, label=equivfst]{Deriving the Explicit \leanw{fst} Combinator}
  \begin{leancode}
/-
  fst α β fn ::[head, tail] = fn head =
    ::[head, tail] fn =* fn head
-/
theorem fst_der (head tail fn : Expr) : IsStep
  (\$ fst, _α, _β, fn, ::[head, tail]) (\$ fn, head) ↔
  (@IsStepStar IsStep) (\$ ::[head, tail],
    (\$ const', ::[β, (\$ nil, β)], α, fn)) (\$ fn, head) := by
  constructor
  intro h_step; cases h_step
  apply IsStepStar.trans; apply IsStep.sapp
  apply IsStepStar.trans; apply IsStep.left
  apply IsStep.const'; apply IsStepStar.refl
  intro h_step; cases h_step
  case mpr.trans e₂ h_step h_trans =>
    cases h_trans; apply IsStep.fst
    apply IsStep.fst
  \end{leancode}
\end{frame}

\begin{frame}[fragile]{Deriving the Explicit \leanw{snd} Combinator}
  \begin{leancode}
/-
  snd α β fn ::[head, tail] = ::[head, tail] fn
  = fn tail head
-/
theorem snd_der (head tail fn : Expr) : IsStep
  (\$ snd, _α, _β, fn, ::[head, tail]) (\$ fn, tail, head) ↔
  (@IsStepStar IsStep) (\$ ::[head, tail], fn) (\$ fn, tail, head) := by
  constructor
  intro h_step; cases h_step
  apply IsStepStar.trans; apply IsStep.sapp
  apply IsStepStar.refl
  case mp.right a =>
    cases a
  intro h_step
  cases h_step
  apply IsStep.snd
  \end{leancode}
\end{frame}

\subsection{Sigma projection is equivalent to application}

\begin{frame}[fragile]{Single-Step Reduction for Sigma Equivalence Proofs}
  \begin{leancode}
inductive IsStep : Expr → Expr → Prop
  | sapp   : IsStep ($ ::[x, f], fn) ($ fn, f, x)
  | nil    : IsStep ($ nil, α, x) α
  | id     : IsStep ($ Expr.id, _α, x) x
  | const' : IsStep ($ const', _α, _β, x, y) x
  | const  : IsStep ($ const, _α, _β, x, y) x
  /- f and g order is flipped here compared to S.
     both f g x = ::[(f x), (g x)]
     both f g x id = id (g x) (f x) -/
  | both   : IsStep ($ both, _α, _β, _γ, f, g, x)
    ::[($f, x), ($ g, x)]
  | left   : IsStep f f'
    → IsStep ($ f, x) ($ f', x)
  | right  : IsStep x x'
    → IsStep ($ f, x) ($ f, x')
  \end{leancode}
\end{frame}


\begin{frame}[fragile]{All Function Applications have corresponding Sigma Projections}
  \begin{leancode}
/-
  (f x) = e' implies (::[x, f] (id t_f)) = e'
-/    
theorem app_imp_proj (t_f f x : Expr) : (@IsStepStar IsStep)
  (\$ f, x) e' → (@IsStepStar IsStep)
  (\$ ::[x, f], (\$ id, t_f)) e' := by
  intro h_step
  cases h_step
  apply IsStepStar.trans; apply IsStep.sapp
  apply IsStepStar.trans; apply IsStep.left
  apply IsStep.id; apply IsStepStar.refl
  apply IsStepStar.trans; apply IsStep.sapp
  apply IsStepStar.trans; apply IsStep.left
  apply IsStep.id; apply IsStepStar.trans
  repeat assumption
  \end{leancode}
\end{frame}

\begin{frame}[fragile, label=equivsigmaapp]{All Function Applications are \(=_{\beta}\) Sigma Projection}
  \begin{leancode}
/-
  (f x) β= (::[x, f] (id t_f))
-/
theorem apps_are_proj (t_f f x : Expr) : (@IsBetaEq IsStep)
  (\$ f, x) (\$ ::[x, f], (\$ id, t_f)) := by
  apply IsBetaEq.symm; apply IsBetaEq.trans
  apply IsBetaEq.rel; apply IsStep.sapp
  apply IsBetaEq.trans; apply IsBetaEq.rel
  apply IsStep.left; apply IsStep.id
  apply IsBetaEq.refl
  \end{leancode}
\end{frame}

\subsection{Deriving the \(S\) combinator from \texttt{both} + projection}

\begin{frame}[fragile, label=equivsapp]{\(S\) combinator = \texttt{id ∘ both}}
  \begin{figure}
    \begin{leancode}
theorem s_both_app_beq (α β γ f g x : Expr') : (@IsBetaEq IsStep)
  ($' s, α, β, γ, f, g, x)
  ($' ($' both, α, β, γ, g, f, x), ($' id, ($' β, z))) := by
  apply IsBetaEq.trans; apply IsBetaEq.rel
  apply IsStep.s; apply IsBetaEq.symm
  apply IsBetaEq.trans; apply IsBetaEq.rel
  apply IsStep.left; apply IsStep.both
  apply IsBetaEq.trans; apply IsBetaEq.rel
  apply IsStep.sapp; apply IsBetaEq.trans
  apply IsBetaEq.rel; apply IsStep.left
  apply IsStep.id; apply IsBetaEq.refl
    \end{leancode}
    \caption{This proof uses an extended AST with the \(S\) combinator for the purposes of this equivalence. Note that the order of \(f\) and \(g\) are flipped between \(S\) and \texttt{both}, since \texttt{both} is sigma-native.}
  \end{figure}
\end{frame}

%\section{Research Questions: \((\Gamma, \Delta)\) Contexts}
%
%\begin{frame}{Hypotheses: Type Contexts}
%  \begin{itemize}
%  
%  \end{itemize}
%\end{frame}

\end{document}
