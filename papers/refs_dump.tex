\input{./papers/template.tex}
\usepackage{bbm}
\usepackage{stmaryrd}
\usepackage{hyperref}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{rsfso}
\usepackage{graphicx}
\usepackage[
  backend=biber,
  style=alphabetic,
  sorting=ynt
]{biblatex}
\addbibresource{./refs.bib}
\usepackage{tikz}
\usepackage{tikz-inet}

\author{Alexandra Aiello}
\date{December 22, 2025}
\title{References Dump}

\begin{document}

\maketitle
\tableofcontents

\section{The Linear Abstract Machine (\textit{LAM})}

\begin{itemize}
  \item We probably won't want to go for the full LAM, since we probably don't need linearity. Linearity might have some appealing properties for ZK, though, so we ought consider it.
  \item At the very least, Lafont's work would give us an idea of how we could extend the more general CAM to support a formal type system: the CAM is untyped by default, and there is no literature on extending it with a proper type system---type safety is enforced structurally via pattern matching, though the behavior is somewhat undefined in the degenerate case.
  \item The cut rule can be eliminated for all sequents \(\Gamma \vdash A\) \autocite[160]{imachine}.
  \item Terminology: intuitionistic is a synonym for \textit{constructive}.
  \item \textit{Classical linear logic is constructive, unlike classical logic} \autocite[161]{imachine}. The paper focuses on this formulation. Probably more powerful, in some ways.
  \item A categorical combinator \(\phi : A \rightarrow B\) represents \(A \vdash B\) \autocite[161]{imachine}. This clarifies the paper I was reading a bit (e.g., \(\phi : \mathbbm{1} \rightarrow B\)).
  \item Linear combinators correspond to the internal logic of \textit{symmetric monoidal closed categories with finite products and coproducts} \autocite[161]{imachine} - how does this differ from a CCC? The paper I read before notes that typing is achieved with a \textit{free} category.
    \begin{itemize}
      \item The combinators are pretty similar to what we've seen already in the CAM paper, but they seem more fine-tuned to linear logic.
      \item How do the linear combinators compare against the \textit{interaction combinators}?
    \end{itemize}
  \item Tensor products \(\otimes\) do not permit accesses / projections, since this would require the weakening rule \autocite[162]{imachine}.
    \begin{itemize}
      \item Tensor products are \textit{strict}, while cartesian products are \textit{lazy} \autocite[162]{imachine}
    \end{itemize}
  \item Recursive datatypes are possible, though they aren't inductive datatypes. The LAM's datatypes are similar to ML's \autocite[163]{imachine}.
  \item NEVERMIND: Lafont presents an implementation of \textit{inductive datatypes}. \textbf{more potential goldmine stuff}
  \item Inductive datatype example: \textbf{Nat}
    \begin{itemize}
      \item \texttt{Nat = \(\mathbbm{1} \oplus\) Nat} (this is pretty standard, but in Lafont's LAM notation) \autocite[163]{imachine}
      \item It is unclear in what sense Lafont is using the word \textit{inductive type}. Would his \textit{inductive types} be sufficient for a ZK proof assistant? What modifications would they require?
      \item An explicit iteration mechanism (\texttt{iter}) is required to achieve general \textit{inductive types}. The inference rules using this primitive are presented for \texttt{Nat} \eqref{infer:nat}.
    \end{itemize}
  \item We can optimize \(\oplus\) and \(\&\) away by the standard \(!A\) operator (``of course'') in linear logic. In doing so, we recover contraction and weakening in a constrained way. \(!A\) is a \textit{free coalgebra} over \(A\) \autocite[163]{imachine}.
  \item Additional combinators are required to lift general ``of course'' statements to combinators \autocite[164]{imachine}, though this seems only necessary for a proof in the appendix.
  \item In this base calculus, intuitionistic logic may be embedded in linear logic \autocite[164]{imachine}.
  \item There is also a translation form categorical combinatory logic (\textit{CCL}) to linear categorical combinatory logic, and every categorical combinator has a linear equivalent, although it is unclear which aixomatic version of CCL Lafont is referencing \autocite[164]{imachine}. As such, the LAM can implement functiona languages, since the CCL is the basis of the CAM \autocite[164]{imachine}. In practice, explosion similar to \(SK\) explosion makes this impractical (\textit{how does Lafont get around this?}).
  \item Shortcut: \(!\Gamma = !A_1, \ldots, !A_n\) - this is not nicely representable in CCL's \autocite[165]{imachine}.
  \item Provides an \textit{execution relation} \autocite[165]{imachine}. This relation could be invaluable for our arithmetization, since it might induce a formal notion of \textit{computational integrity} for an architecture based on it.
  \item Lafont suggests a category representing the model, where the points are \textit{atomic types} (e.g., states) and the arrows are \textit{atomic combinators} (e.g., execution actions / instructions) \autocite[165]{imachine}.
  \item Tensor products are defineable on atomic types and atomic combinators. They are referred to as \textit{primitive types} and \textit{primitive combinators} (i.e., \textbf{program effects}), respectively \autocite[165]{imachine}. Domains and codomains of functions (\textit{primitive combinators}) are primitive types \autocite[165]{imachine.}
  \item Canonical combinators: The LAM's computational model supports some flavor of type dependency, though it's not clear how expressive it really is. The \textit{canonical combinators} for some type \(A\) correspond roughly to the \textbf{slice category} \(C / A\) \autocite[165]{imachine}.
    \begin{itemize}
      \item The identity function / combinator is the only example for atomics.
      \item Canonical combinators on tensor products are mappings over the projections.
      \item The identity is the only canonical combiantor on \(\mathbbm{1}\) (\textit{does \(\mathbbm{1}\) correspond to the terminal object?})
      \item Compositions of ``constructors'' for a given type \(A\) with a canonical are the only canonicals for other types.
    \end{itemize}
  \item Programs deal with \textit{canonical combinators} as their operative datum \autocite[165]{imachine}.
  \item Execution relation is defined inductively, which is not ideal for ZK. We would like an equational theory. If he gave one, that would be awesome \autocite[166]{imachine}.
  \item Practical implementation: the LAM. The LAM uses a similar architecture to the CAM, with codes, environments, and stacks. This gives the equational theory we would like, thus being ideal for ZK \autocite[167]{imachine}.
    \begin{itemize}
      \item The LAM appears to offer parallel and sequential implementations, which could speed up our ZK in some way, though there is probably a tradeoff between proving speed, verification speed, and AIR thinness. Intuition says that the sequential model would offer a thinner ZK-AIR.
      \item Environment (e.g., variable being substituted in a \(\lambda\) eval) is a ``representation'' of a canonical combinator. It's not clear whether representation refers to a De Bruijn representation, or the actual code of the term.
      \item Tensor products map directly onto pairs---not couples.
      \item The ``terminal object'' maps onto an empty pair, though I'm not sure if base CAM supports this.
      \item Composition also maps onto a pair.
      \item Codes differ between sequential and parallel composition models: concatenation and sequentialization, respectively \autocite[167]{imachine}.
      \item In total, there are 16 codes.
      \item Integers and operations on them might be added as primitives, but they require duplication and erasure instructinos \autocite[168]{imachine}.
      \item Can also extend the machine with \textit{effects} like IO \autocite[168]{imachine}.
      \item Since memory does not need to be shared \autocite[170]{imachine}, side effects are in some sense purer than in other FP's.
      \item Due to memory sharing in the CAM, cells in the environment cannot be reused safely after access. Garbage collection is a necessary optimization in the CAM. \autocite[171]{imachine}. This seems like a major scalability limitation for ZK.
      \item The LAM, by contrast, does not require a garbage collector, and memory cells can generally be salvaged \autocite[171]{imachine}.
      \item Instsructions in the LAM perform garbage collection automatically, although we might not want this, since we're optimizing for a flat AIR \autocite[171]{imachine}.
      \item Reduction in linear \(\lambda\)-calculus always terminates in linear time \autocite[173]{imachine}.
    \end{itemize}
\end{itemize}

\begin{figure}[h]
  \begin{equation}
    \begin{aligned}
      \frac{}{\text{zero}: \mathbbm{1} \rightarrow \text{Nat}}& &\frac{}{\text{succ}: \text{Nat} \rightarrow \text{Nat}}& &\frac{\phi: \mathbbm{1} \rightarrow A, \phi : A \rightarrow A}{\text{iter}(\phi, \psi): \text{Nat} \rightarrow A}
    \end{aligned}
  \end{equation}
  \caption{Inference rules for an inductive datatype \texttt{Nat} \autocite[163]{imachine}}\label{infer:nat}
\end{figure}

\begin{figure}[h]
  \begin{equation}
    \begin{aligned}
      &\frac{\phi : A \rightarrow B, \psi : B \rightarrow C}{\psi \circ \phi : A \rightarrow C} &\frac{}{\textbf{id}: A \rightarrow A}\\
      &\frac{\phi : A \rightarrow B, \psi : C \rightarrow D}{\phi \otimes \psi : A \otimes C \rightarrow B \otimes D} &\frac{}{\mathbbm{1} : \mathbbm{1} \rightarrow \mathbbm{1}}\\
      &\frac{}{\textbf{assl}: A \otimes (B \otimes C) \iff (A \otimes B) \otimes C : \textbf{assr}}&\\
      &\frac{}{\textbf{insl}: A \iff \mathbbm{1} \otimes A : \textbf{dell}} &\frac{}{\textbf{exch}: A \otimes B \iff B \otimes A:\textbf{exch}}
    \end{aligned}
  \end{equation}
  \caption{Inference rules for the sequential compositors, parallel compositors, and arrange combinators of the \textit{linear combinators} \autocite[161]{imachine}}
\end{figure}

\begin{figure}[h]
  \begin{equation}
    \begin{aligned}
      &\frac{\phi : A \otimes B \rightarrow C}{\textbf{cur}(\phi): A \rightarrow B \multimap C} &\frac{}{\textbf{app}: (A \multimap B) \otimes A \rightarrow B}&&&&\\
      &\frac{\phi: A \rightarrow B, \psi : A \rightarrow C}{\langle \phi, psi \rangle: A \rightarrow B \& C} &\frac{}{\textbf{fst}: A \& B \rightarrow A} &\frac{}{\textbf{snd}: A \& B \rightarrow B} &\frac{}{\langle \rangle: A \rightarrow \tau}&&\\
      &\frac{}{\textbf{inl}: A \rightarrow A \oplus B} &\frac{}{\textbf{inr}: B \rightarrow A \oplus B} &\frac{\phi: A \rightarrow C, \psi: B \rightarrow C}{\{\phi | \psi\} : A \oplus B \rightarrow C} &\frac{}{\{\}: \mathbbm{0} \rightarrow A}&&
    \end{aligned}
  \end{equation}
  \caption{Inference rules for the logical combinators of the \textit{linear combinators} \autocite[162]{imachine}}
\end{figure}

\printbibliography{}

\end{document}
