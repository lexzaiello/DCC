@InProceedings{altenkirch,
  author =	{Altenkirch, Thorsten and Kaposi, Ambrus and \v{S}inkarovs, Artjoms and V\'{e}gh, Tam\'{a}s},
  title =	{{The M\"{u}nchhausen Method in Type Theory}},
  booktitle =	{28th International Conference on Types for Proofs and Programs (TYPES 2022)},
  pages =	{10:1--10:20},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-285-3},
  ISSN =	{1868-8969},
  year =	{2023},
  volume =	{269},
  editor =	{Kesner, Delia and P\'{e}drot, Pierre-Marie},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.TYPES.2022.10},
  URN =		{urn:nbn:de:0030-drops-184534},
  doi =		{10.4230/LIPIcs.TYPES.2022.10},
  annote =	{Keywords: type theory, proof assistants, very dependent types}
}
@article{MAZZA_2007,
	title        = {A denotational semantics for the symmetric interaction combinators},
	author       = {Mazza, Damiano},
	year         = 2007,
	journal      = {Mathematical Structures in Computer Science},
	volume       = 17,
	number       = 3,
	pages        = {527–562},
	doi          = {10.1017/S0960129507006135}
}
@misc{cryptoeprint:2018/046,
      author = {Eli Ben-Sasson and Iddo Bentov and Yinon Horesh and Michael Riabzev},
      title = {Scalable, transparent, and post-quantum secure computational integrity},
      howpublished = {Cryptology {ePrint} Archive, Paper 2018/046},
      year = {2018},
      url = {https://eprint.iacr.org/2018/046}
}
@article{FERNANDEZ2003157,
	title        = {Operational equivalence for interaction nets},
	author       = {Maribel Fernández and Ian Mackie},
	year         = 2003,
	journal      = {Theoretical Computer Science},
	volume       = 297,
	number       = 1,
	pages        = {157--181},
	doi          = {https://doi.org/10.1016/S0304-3975(02)00637-0},
	issn         = {0304-3975},
	url          = {https://www.sciencedirect.com/science/article/pii/S0304397502006370},
	note         = {Latin American Theoretical Informatics},
	keywords     = {Interaction nets, Bisimulation equivalence, Operational semantics},
	abstract     = {The notion of contextual (or operational) equivalence is fundamental in the theory of programming languages. By setting up a notion of bisimilarity, and showing that it coincides with contextual equivalence, one obtains a simple coinductive proof technique for showing that two programs are equivalent in all contexts. In this paper we apply these (now standard) techniques to interactions nets, a graphical programming language characterized by local reduction. This work generalizes previous studies of operational equivalence in typed interaction nets since it can be applied to untyped systems, thus all systems of interaction nets are captured.}
}
@article{Levy,
author = {Lévy, Jean-Jacques},
copyright = {1976},
issn = {0304-3975},
journal = {Theoretical computer science},
language = {eng},
number = {1},
pages = {97-114},
publisher = {Elsevier B.V},
title = {An algebraic interpretation of the λβ K-calculus; and an application of a labelled λ-calculus},
volume = {2},
year = {1976},
}
@article{LAFONT199769,
title = {Interaction Combinators},
journal = {Information and Computation},
volume = {137},
number = {1},
pages = {69-101},
year = {1997},
issn = {0890-5401},
doi = {https://doi.org/10.1006/inco.1997.2643},
url = {https://www.sciencedirect.com/science/article/pii/S0890540197926432},
author = {Yves Lafont},
abstract = {It is shown that a very simple system ofinteraction combinators, with only three symbols and six rules, is a universal model of distributed computation, in a sense that will be made precise. This paper is the continuation of the author's work oninteraction nets, inspired by Girard's proof nets forlinear logic, but no preliminary knowledge of these topics is required for its reading.}
}
@article{10.1137/S0097539795284959,
author = {Micali, Silvio},
title = {Computationally Sound Proofs},
year = {2000},
issue_date = {2000},
publisher = {Society for Industrial and Applied Mathematics},
address = {USA},
volume = {30},
number = {4},
issn = {0097-5397},
url = {https://doi.org/10.1137/S0097539795284959},
doi = {10.1137/S0097539795284959},
abstract = {This paper puts forward a new notion of a proof based on computational complexity and explores its implications for computation at large. Computationally sound proofs provide, in a novel and meaningful framework, answers to old and new questions in complexity theory. In particular, given a random oracle or a new complexity assumption, they enable us to prove that verifying is easier than deciding for all theorems; provide a quite effective way to prove membership in computationally hard languages (such as ${cal C}o$-$cal N cal P$-complete ones); and show that every computation possesses a short certificate vouching its correctness. Finally, if a special type of computationally sound proof exists, we show that Blum's notion of program checking can be meaningfully broadened so as to prove that $cal N cal P$-complete languages are checkable.},
journal = {SIAM J. Comput.},
month = oct,
pages = {1253–1298},
numpages = {46},
keywords = {random oracles, probabilistically checkable proofs, interactive proofs, Merkle trees}
}
@misc{cryptoeprint:2014/595,
      author = {Eli Ben-Sasson and Alessandro Chiesa and Eran Tromer and Madars Virza},
      title = {Scalable Zero Knowledge via Cycles of Elliptic Curves},
      howpublished = {Cryptology {ePrint} Archive, Paper 2014/595},
      year = {2014},
      url = {https://eprint.iacr.org/2014/595}
}
@article{10.1145/273865.273901,
author = {Arora, Sanjeev and Safra, Shmuel},
title = {Probabilistic checking of proofs: a new characterization of NP},
year = {1998},
issue_date = {Jan. 1998},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {45},
number = {1},
issn = {0004-5411},
url = {https://doi.org/10.1145/273865.273901},
doi = {10.1145/273865.273901},
abstract = {We give a new characterization of NP: the class NP contains exactly those languages L for which membership proofs (a proof that an input x is in L) can be verified probabilistically in polynomial time using logarithmic number of random bits and by reading sublogarithmic number of bits from the proof.We discuss implications of this characterization; specifically, we show that approximating Clique and Independent Set, even in a very weak sense, is NP-hard.},
journal = {J. ACM},
month = jan,
pages = {70–122},
numpages = {53},
keywords = {NP-completeness, approximation algorithms, complexity hierarchies, computations on polynomials and finite fields, error-correcting codes, hardness of approximations, interactive computation, probabilistic computation, proof checking, reducibility and completeness, trade-offs/relations among complexity measures}
}
@inproceedings{10.1145/22145.22178,
author = {Goldwasser, S and Micali, S and Rackoff, C},
title = {The knowledge complexity of interactive proof-systems},
year = {1985},
isbn = {0897911512},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/22145.22178},
doi = {10.1145/22145.22178},
booktitle = {Proceedings of the Seventeenth Annual ACM Symposium on Theory of Computing},
pages = {291–304},
numpages = {14},
location = {Providence, Rhode Island, USA},
series = {STOC '85}
}
@misc{cryptoeprint:2021/1063,
      author = {Lior Goldberg and Shahar Papini and Michael Riabzev},
      title = {Cairo – a Turing-complete {STARK}-friendly {CPU} architecture},
      howpublished = {Cryptology {ePrint} Archive, Paper 2021/1063},
      year = {2021},
      url = {https://eprint.iacr.org/2021/1063}
}
@inproceedings{inets,
author = {Lafont, Yves},
title = {Interaction nets},
year = {1989},
isbn = {0897913434},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/96709.96718},
doi = {10.1145/96709.96718},
abstract = {We propose a new kind of programming language, with the following features:Interaction nets generalize Girard's proof nets of linear logic and illustrate the advantage of an integrated logic approach, as opposed to the external one. In other words, we did not try to design a logic describing the behaviour of some given computational system, but a programming language for which the type discipline is already (almost) a logic.In fact, we shall scarcely refer to logic, because we adopt a na\"{\i}ve and pragmatic style. A typical application we have in mind for this language is the design of interactive softwares such as editors or window managers.},
booktitle = {Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {95–108},
numpages = {14},
location = {San Francisco, California, USA},
series = {POPL '90}
}
@article{imachine,
title = {The linear abstract machine},
journal = {Theoretical Computer Science},
volume = {59},
number = {1},
pages = {157-180},
year = {1988},
issn = {0304-3975},
doi = {https://doi.org/10.1016/0304-3975(88)90100-4},
url = {https://www.sciencedirect.com/science/article/pii/0304397588901004},
author = {Y. Lafont},
abstract = {Linear Logic [6] provides a refinement of functional programming and suggests a new implementation technique, with the following features: a synthesis of strict and lazy evaluation;a clean semantics of side effects;no garbage collector.}
}
@InProceedings{cmachine,
author="Cousineau, G.
and Curien, P-L.
and Mauny, M.",
editor="Jouannaud, Jean-Pierre",
title="The categorical abstract machine",
booktitle="Functional Programming Languages and Computer Architecture",
year="1985",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="50--64",
abstract="The Cartesian closed categories have been shown by several authors to provide the right framework of the model theory of $\lambda$-calculus. The second author developed this as a syntactic equivalence between two calculi, giving rise to a new kind of combinatory logic: the categorical combinatory logic, where computations can be done through simple rewrite rules, and, as usual with combinators, avoiding problems with variable name clashes. This paper goes further (though not requiring a previous knowledge of categorical combinatory logic) and describes a very simple machine where categorical terms can be considered as code acting on a graph of values. The only saving mechanism is a stack containing pointers on code or on the graph. Abstractions are handled using closures. The machine is called categorical abstract machine or CAM. The CAM is easier to grasp and prove than the SECD machine. The natural evaluation strategy in the CAM is call-by-value, but lazy evaluation can be easily incorporated. The paper discusses the implementation of a real functional programming language, ML, through the CAM. A basic acquaintance with $\lambda$-calculus is required.",
isbn="978-3-540-39677-2"
}
@book{10.5555/1096899,
author = {Peyton Jones, Simon L.},
title = {The Implementation of Functional Programming Languages (Prentice-Hall International Series in Computer Science)},
year = {1987},
isbn = {013453333X},
publisher = {Prentice-Hall, Inc.},
address = {USA}
}
@article{Seely_1984, title={Locally cartesian closed categories and type theory}, volume={95}, DOI={10.1017/S0305004100061284}, number={1}, journal={Mathematical Proceedings of the Cambridge Philosophical Society}, author={Seely, R. A. G.}, year={1984}, pages={33–48}}
@article{CURIEN1986188,
title = {Categorical combinators},
journal = {Information and Control},
volume = {69},
number = {1},
pages = {188-254},
year = {1986},
issn = {0019-9958},
doi = {https://doi.org/10.1016/S0019-9958(86)80047-X},
url = {https://www.sciencedirect.com/science/article/pii/S001999588680047X},
author = {P.-L. Curien},
abstract = {Our main aim is to present the connection between λ-calculus and Cartesian closed categories both in an untyped and purely syntactic setting. More specifically we establish a syntactic equivalence theorem between what we call categorical combinatory logic and λ-calculus with explicit products and projections, with β and η-rules as well as with surjective pairing. “Combinatory logic” is of course inspired by Curry's combinatory logic, based on the well-known S, K, I. Our combinatory logic is “categorical” because its combinators and rules are obtained by extracting untyped information from Cartesian closed categories (looking at arrows only, thus forgetting about objects). Compiling λ-calculus into these combinators happens to be natural and provokes only n log n code expansion. Moreover categorical combinatory logic is entirely faithful to β-reduction where combinatory logic needs additional rather complex and unnatural axioms to be. The connection easily extends to the corresponding typed calculi, where typed categorical combinatory logic is a free Cartesian closed category where the notion of terminal object is replaced by the explicit manipulation of applying (a function to its argument) and coupling (arguments to build datas in products). Our syntactic equivalences induce equivalences at the model level. The paper is intended as a mathematical foundation for developing implementations of functional programming languages based on a “categorical abstract machine,” as developed in a companion paper (Cousineau, Curien, and Mauny, in “Proceedings, ACM Conf. on Functional Programming Languages and Computer Architecture,” Nancy, 1985).}
}
@article{ABEL200717,
title = {Normalization by Evaluation for Martin-Löf Type Theory with One Universe},
journal = {Electronic Notes in Theoretical Computer Science},
volume = {173},
pages = {17-39},
year = {2007},
note = {Proceedings of the 23rd Conference on the Mathematical Foundations of Programming Semantics (MFPS XXIII)},
issn = {1571-0661},
doi = {https://doi.org/10.1016/j.entcs.2007.02.025},
url = {https://www.sciencedirect.com/science/article/pii/S1571066107000977},
author = {Andreas Abel and Klaus Aehlig and Peter Dybjer},
keywords = {Dependent Types, Domain Semantics, Normalization by Evaluation, Type Theory, Universe},
abstract = {We present an algorithm for computing normal terms and types in Martin-Löf type theory with one universe and eta-conversion. We prove that two terms or types are equal in the theory iff the normal forms are identical (as de Bruijn terms). It thus follows that our algorithm can be used for deciding equality in Martin-Löf type theory. The algorithm uses the technique of normalization by evaluation; normal forms are computed by first evaluating terms and types in a suitable model. The normal forms are then extracted from the semantic elements. We prove its completeness by a PER model and its soundness by a Kripke logical relation.}
}
@article{Turner1979ANI,
  title={A new implementation technique for applicative languages},
  author={David Turner},
  journal={Software: Practice and Experience},
  year={1979},
  volume={9},
  url={https://api.semanticscholar.org/CorpusID:40541269}
}