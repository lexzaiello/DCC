\input{./papers/template.tex}
\usepackage{bbm}
\usepackage{stmaryrd}
\usepackage{hyperref}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{rsfso}
\usepackage{graphicx}
\usepackage[
  backend=biber,
  style=alphabetic,
  sorting=ynt
]{biblatex}
\addbibresource{./refs.bib}
\usepackage{tikz}
\usepackage{tikz-inet}

\author{Alexandra Aiello}
\date{December 22, 2025}
\title{Adapting Abstract Machine Equations to Dependent Typing}

\begin{document}

\maketitle
\tableofcontents

\section{Overview}

Lafont's linear abstract machine (\textit{LAM}) \cite{imachine} and the categorical abstract machine devised by Cousineau et al. (\textit{CAM}) \cite{cmachine} provide efficient execution schemes for \(\lambda\)-like calculi. Notably, the LAM provides an execution environment for \textit{classical intuitionistic logic}, thereby corresponding to symmetric monoidal closed categories with finite products and coproducts \autocite[161]{imachine}. It is unclear what advantages classical linear logic would provide for zero-knowledge proofs, but Lafont's adaptation of the CAM may provide insight to our adaptation of the CAM.

Ideally, we would extend the CAM's correspondence with cartesian closed categories (\textit{CCC}'s) \autocite[178]{cmachine} to locally cartesian closed categories (\textit{LCCC}'s), thereby enabling Martin-LÃ¶f Type Theory (\textit{MLTT}). Here, I outline a potential approach for adapting the CAM to achieve this goal by adding explicit dependent type arguments with corresponding meta-combinator registers.

\section[Equational Semantics in the CAM]{The CAM Achieves its Correspondence via Equational Semantics}

\subsection{TODO: Consolidate}

\begin{itemize}
  \item Cousineau et al. motivate the design of the CAM through a well-known semantics for the untyped \(\lambda\)-calculus. \autocite[175]{cmachine}.
  \item The design of the CAM is derived from a transformation of the semantics for \(\lambda\)-calculus to an equationa, syntactic interpretation with some similarity to the \(SK\)-calculus \autocite[176]{cmachine}.
  \item They extend the CAM with explicit pairs to more closely align execution with a performant memory-model (i.e., binary-tree environments), thus yielding a correspondence to CCC's \autocite[178]{cmachine}.
  \item We can keep most of the CAM's design the same, thus inheriting its performance benefits and its support for variable environments.
  \item As we have seen before, we can extend the \(SK\)-calculus with arguments for explicit types, enabling polymorphism, or even dependent typing.
\end{itemize}

\subsection{TODO: Consolidate---The CAM does not have type-checking by default}

\begin{itemize}
  \item The CAM does not support explicit typing, but still corresponds to CCC's \textit{by construction}. For example, Cousineau et al. give a compilation from ML to the CAM, but rely on ML's type-checking to achieve this \autocite[196]{cmachine}. However, in dependent typing, types are somewhat computationally relevant, so this will not be sufficient for our use case.
\end{itemize}

\begin{figure}
  \begin{equation}
    \begin{aligned}
      0!(x, y) = y,&\quad (n + 1)!(x, y) = n!x,&\\
      ('x)y = x,&&\\
      S(x, y)z = xz(yz),&&\\
      \Lambda(x)yz = x(y, z)&&\\
    \end{aligned}
  \end{equation}
  \caption{Syntactic rules motivating the CAM, bearing similarity to the \(SK\)-calculus \autocite[176]{cmachine}.}\label{skequations}
\end{figure}

\begin{itemize}
  \item The first 3 equations \eqref{skequations} correspond to the \(K\) rule, while the second two correspond to \(S\).
  \item We don't extend \(SK\) with additional combinators, and we will still need pairs. But, our \(\beta\)-reduction ruels for \(SK\) differ, in that they have explicit type arguments that are also ``forgotten'', except at the meta-level.
  \item We will likely add some kind of meta register with its own pattern-matching rules to enforce our type discipline.
  \item The linear abstract machine doesn't have types at its base level, either. We are somewhat forced to do our typing \textit{by construction.}
  \item Doing dependent typing is kind of difficult, since it requires beta reduction. This contradicts the ``by construction'' viewpoint. There is no beta reduction required in standard linear logic.
  \item LCCC's are just a category where all the slice categories are CCC's.
\end{itemize}  

\printbibliography{}

\end{document}
