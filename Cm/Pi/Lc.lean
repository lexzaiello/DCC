import Mathlib.Data.Nat.Notation

import Cm.Pi.Ast
import Cm.Pi.Eval
import Cm.Pi.Util
import Cm.Pi.Curry

open Std (Format)
open Std (ToFormat)
open Std.ToFormat (format)

open Expr

abbrev DebruijnIdx := ℕ

/-
A lambda calculus expression where variables are represented by
the type α.
-/
inductive LcExpr (α : Type) where
  | app : LcExpr α
    → LcExpr α
    → LcExpr α
  | lam : LcExpr α
    → LcExpr α
  | var : α → LcExpr α
  | symbol : String -- our machine has these
    → LcExpr α

def LcExpr.fmt : (LcExpr DebruijnIdx) → Format
  | .app f x => "f$ " ++ Format.paren (.group <| .nest 2 <| f.fmt ++ Format.line ++ x.fmt)
  | .var n => s!".var {n}"
  | .lam body => "(λ! " ++ .paren body.fmt ++ ")"
  | .symbol s => s!"(symbol {s})"

instance LcExpr.instToFormat : ToFormat (LcExpr DebruijnIdx) where
  format := LcExpr.fmt

instance LcExpr.instToString : ToString (LcExpr DebruijnIdx) where
  toString := toString ∘ format

notation "λ!" => LcExpr.lam
notation "f$" => LcExpr.app
notation:max "#" => @LcExpr.var DebruijnIdx

/-
We should be able to detect the arity of expressions before compiling.
This is just the maximum lambda depth.

λ 0 => this should always compile to id

λ ($f 0 0) => this should compile to (:: both (:: (quote apply) (:: both id id)))

λ 1 => this is a completely free variable. should compile to (quote const)
λ 2 => this is a completely free variable. it should do the sasme substitution
that λ λ 1 does. only makes sense within a 

λ λ 0 => this should compile to (quote (quote id))

λ λ 1 => this should compile to (:: both (:: (quote const) id))

argument passing format:
(:: both (:: (quote apply) (:: both T[x] T[x])))

Why do free variables matter? Why can't we just pass eagerly call the inner lambda if we have nested lambdas?

λ 1 => (quote const)
λ 2 => (quote (quote const))

λ λ 1 => (:: both (:: (quote const) id))

we could also just decrement all free variables as we traverse under lambdas.
λ λ 1 => don't decrement 1, since it is BOUND (:: both (:: (quote const) id))

λ λ 2 => decrement 1,


-/

def mk_n_const (n : ℕ) (inner_e : Expr) : Expr := (List.replicate n Expr.const).foldr (fun _e acc => (quote acc)) inner_e

/-
Note that expressions generated by abstract are inert.
You must ::apply them with argumnets.

If the body of a lambda contains only bound expressions, we should just const it.

λ λ 1 => (:: const id)
-/

def is_bound (var depth : ℕ) : Bool := var < depth

def all_bound (depth : ℕ) : LcExpr DebruijnIdx → Bool
  | .var n => is_bound n depth
  | .lam b => all_bound depth.succ b
  | .symbol _s => true
  | .app f x => all_bound depth f && all_bound depth x

/-
Need to do the same "substitution" thing at the top level
-/
def abstract (depth : ℕ) : LcExpr DebruijnIdx → Expr
  | .var n =>
    if is_bound n depth then
      -- if this variable is bound, then
      -- λ (λ 0) => (const (const id))
      mk_n_const (depth - 1 - n) id
    else
      -- this is the free variable case
      mk_n_const (n - depth) id -- depth is handled in lambda nesting case
  | .symbol s => (:: const (symbol s))
  | .lam b =>
    /-
      If all inner lambdas are free, then we should const the result after running it
    -/
    let t_b := abstract depth.succ b
    if ¬ all_bound depth b then
      (:: both (:: (quote const) t_b))
    else t_b
  | .app f x =>
    let t_f := abstract depth f
    let t_x := abstract depth x

    (:: both (:: (quote apply) (:: both (:: t_f t_x))))

def Expr.of_lc : LcExpr DebruijnIdx → Except Error Expr
  | .lam b => pure <| abstract 1 b
  | .app f x => do
    let t_f ← Expr.of_lc f
    let t_x ← Expr.of_lc x
    pure <| (:: apply (:: t_f t_x))
  | .symbol s => pure <| symbol s
  | _ => .error <| .var_in_output

-- λ 0 => id
#eval Expr.of_lc (f$ (λ! (.var 0)) (.symbol "hi"))
  >>= do_step run

#eval Expr.of_lc (f$ (f$ (λ! (λ! (.var 0))) (.symbol "discard")) (.symbol "hi"))
  >>= do_step run

#eval Expr.of_lc (f$ (f$ (λ! (λ! (.var 1))) (.symbol "hi")) (.symbol "discard"))
  >>= do_step run

def mk_test (lam_e : LcExpr DebruijnIdx) (step_with : Expr → Except Error Expr := run) : Except Error Expr := do
  let cm_e ← Expr.of_lc lam_e
  do_step step_with cm_e

def tre_lc : LcExpr DebruijnIdx := λ! (λ! (# 1))

def flse_lc : LcExpr DebruijnIdx := λ! (λ! (# 0))

def example_tre := mk_test (f$ (f$ tre_lc (.symbol "a")) (.symbol "b"))
def example_flse := mk_test (f$ (f$ flse_lc (.symbol "a")) (.symbol "b"))

#eval example_tre
#eval example_flse

/-
Potential translation with positinal parameters:

Argument lists always contain one thing, so

outer lambda here should just return the inner lambda

we should always be feeding arguments down the lambda chain.

(λ λ 0) a b - in this one, the inner lambda has a depth of 1, so :: const id

(λ λ 1) a b => (:: apply (:: (:: apply (:: f a)) b))

Make a context of substitutions, which is the list of arguments.
-/

/-namespace positional

open Expr

def apply_now_pointfree : Expr :=
  (:: both (:: (:: const apply) id))

/-
Fetches the nth value in the context / positional arguments,
and strips the nil value

Suspicion: const apply whatever should only happen at the very end
recursively.

We can just eval at the very end I guess.
Or do a similar trick with nil.

If inner is :: x nil, then
we can do a π inside

π id _

I want to optimize this more.

could do (:: const (:: both id (:: const nil)))

(:: both (:: (:: const const) id))

Perhaps opposite order.
We're just continually popping off the stack.
Shouldn't be too hard.

Oh yo idea. :: then_cons

Then we get something that we can lazilly put on our stack.

We can be lazy. Nested id is fine.
We're not introducing any new nil values.
-/

/-
Assume we can fetch arguments in opposite order / appended order.
-/

def append_ctx (with_val : Expr) : Expr → Expr
  | nil => :: nil with_val
  | :: nil xs => :: xs with_val
  | :: x xs => :: (:: x xs) with_val
  | l => :: l with_val

def get_nth_pos (n : ℕ) : Expr :=
  match n with
  | .succ n =>
    

#eval do_step run (:: apply (:: (get_nth_pos 1) (:: (:: (symbol "Hello, world") (symbol "a")) (symbol "b"))))
#eval do_step run (:: apply (:: (get_nth_pos 0) (:: (:: (symbol "Hello, world") (symbol "a")) (symbol "b"))))
#eval do_step run (:: apply (:: (get_nth_pos 1) (:: (:: (symbol "Hello, world") (symbol "a")) (symbol "b"))))
--#eval do_step run (:: apply (:: (get_nth_pos 2) (:: (symbol "0th") (:: (symbol "1th") (:: (symbol "2nd") nil)))))

abbrev TCtx := Expr

mutual

/-
ONLY for λ bodies. arg is the λ body
Pretty sure we just need to fix incrementing bound variables

vars will already be quoted if they are free.
not free variables are not quoted.

Not sure why we can't just do both inside the app case.

if .var n == 0 then don't quote.
otherwise,

we should only ever be doing get_nth_pos 0.

Otherwise,

λ λ 1

at each app in .of_lc, we prepend x
to the context.

For top-level lambdas, there is no context.
-/
def abstract (depth : ℕ) : LcExpr DebruijnIdx → Expr
  | .var n =>
    -- by the time we get to this position,
    -- we should just be doing π id nil
    -- λ λ 1 => (:: const id)
    -- λ 0 => id
    dbg_trace s!"depth: {depth} n: {n}"
    get_nth_pos (n + 1)
    --:: both (:: (List.replicate (depth - 1) const
    --|> (·.foldr (fun e acc => :: e acc) const)) id)
  | .app f x =>
    let f' := abstract depth f
    let x' := abstract depth x

    (:: both (:: (quote apply) (:: both (:: (:: both (:: (quote apply) (:: both (:: (quote f') x')))) id))))
  | .lam body => abstract depth.succ body
  -- symbol in body, so we should quote it
  | .symbol s => (symbol s)

/-
  Issue to fix:
  we're adding onto ctx the wrong way in Expr.of_lc_ctx
  Why doesn't f' receive ctx'? fuck it.
-/

def cons_ctx (with_val : Expr) : Expr → Expr
  | nil => with_val
  | l => :: with_val l

/-
Things for tomorrow:
- ctx' always has only one thing in it.
- depth should probably start at 1 in lam case
-/

def Expr.of_lc_ctx : LcExpr DebruijnIdx → Except Error (Expr × TCtx)
  | .var _n => .error .var_in_output
  | .lam b => pure <| ⟨(abstract 0 b), nil⟩
  | .app f x => do
    let ⟨x', ctx⟩ ← Expr.of_lc_ctx x
    let x_eval := match ctx with
      | nil => x'
      | ctx => (:: apply (:: x' ctx))
    let ⟨f', ctx_f⟩ ← Expr.of_lc_ctx f
    let ctx' := (append_ctx x_eval ctx_f)
    dbg_trace s!"{ctx'}"

    pure <| ⟨f', ctx'⟩
  | .symbol s => pure <| ⟨symbol s, nil⟩

def Expr.of_lc (e : LcExpr DebruijnIdx) : Except Error Expr := do
  let ⟨e', ctx⟩ ← Expr.of_lc_ctx e
  match ctx with
  | nil => pure e'
  | ctx => pure (:: apply (:: e' ctx))

end

def mk_test (step_with : Expr → Except Error Expr) (lam_e : LcExpr DebruijnIdx) : Except Error Expr := do
  let cm_e ← Expr.of_lc lam_e
  do_step step_with cm_e

/-
(λ x.x) (symbol "Hello, world")
-/

def test_hello_world₀ := (f$ (λ! (.var 0)) (.symbol "Hello, world"))
  |> mk_test run

#eval test_hello_world₀ >>= (pure <| · == (:: nil (symbol "Hello, world")))

def test_hello_world_nest := (f$ (f$ (f$ (λ! (λ! (λ! (.var 0)))) (.symbol "Hello, world")) (.symbol "a")) (.symbol "b"))
  |> mk_test run

def test_hello_world_nest_up := (f$ (f$ (f$ (λ! (λ! (λ! (.var 1)))) (.symbol "Hello, world")) (.symbol "a")) (.symbol "b"))
  |> mk_test run

#eval test_hello_world_nest_up

#eval test_hello_world_nest
#eval test_hello_world_nest >>= (pure <| · == (:: nil (symbol "b")))

def test_hello_world₁ := (f$ (f$ (f$ (λ! (λ! (λ! (f$ (.var 1) (.var 0))))) (.symbol "Hello, world")) (.symbol "hi")) (.symbol "a"))
  |> mk_test run

#eval test_hello_world₁ >>= (pure <| · == :: apply (:: (symbol "hi") (symbol "a")))
#eval test_hello_world₀ >>= (pure <| · == (symbol "Hello, world"))

def test_hello_world_id := (f$ (f$ (f$ (λ! (λ! (λ! (f$ (.var 1) (.var 0))))) (.symbol "Hello, world")) (λ! (.var 0))) (.symbol "a"))
  |> mk_test run

#eval test_hello_world_id >>= (pure <| · == (symbol "a"))

def test_hello_world := (f$ (λ! (f$ (λ! (f$ (λ! (.var 0)) (.var 0))) (.var 0))) (.symbol "Hello, world"))
  |> mk_test run

#eval test_hello_world >>= (pure <| ·== (symbol "Hello, world"))

/-
Church encoding of true. should get the first argument.

tre a b = a
tre = λ λ.1
-/

def tre_lc := (λ! (λ! (.var 1)))
def tre := (f$ (f$ tre_lc (.symbol "Hello, world")) (.symbol "other"))
  |> mk_test run

#eval tre

--#eval test_hello_world
#eval tre >>= (pure <| · == (symbol "other"))
--#eval Expr.of_lc tre_lc

/-
Church encoding of false. should get the second argument.
-/

def flse_lc := (λ! (λ! (.var 0)))
def flse := f$ (f$ flse_lc (.symbol "Hello, world")) (.symbol "other")
  |> mk_test run

#eval flse >>= (pure <| · == (symbol "other"))

/-
(flse "hello world" (λx.x)) ("hello world")
-/

def flse_i_app := f$ (f$ (f$ (λ! (λ! (.var 0))) (.symbol "bruh")) (λ! (.var 0))) (.symbol "Hello, world")
  |> mk_test run

--#eval flse_i_app

def tre_i_app := f$ (f$ (f$ (λ! (λ! (.var 1))) (λ! (.var 0))) (.symbol "Hello, world")) (.symbol "Hello, world")
  |> mk_test run

--#eval tre_i_app

def zero_lc := λ! (λ! (.var 0))

def zero_hello_world_app := f$ (f$ zero_lc (λ! (.var 0))) (.symbol "Hello, world")
  |> mk_test run

--#eval zero_hello_world_app

-- succ n f x = f (n f x)
-- f is bound to the second lambda
-- n is bound to the top lambda
def succ_lc := λ! (λ! (λ! (f$ (.var 1) (f$ (f$ (.var 2) (.var 1)) (.var 0)))))

--#eval succ_lc

--#eval Expr.of_lc succ_lc

def succ_nfx_lc := λ! (λ! (λ! (f$ (f$ (.var 2) (.var 1)) (.var 0))))

def one_hello_world_app := f$ (f$ (f$ succ_lc zero_lc) (λ! (.var 0))) (.symbol "Hello, world")
  |> mk_test run

--#eval one_hello_world_app

def two_hello_world_app := f$ (f$ (f$ succ_lc (f$ succ_lc zero_lc)) (λ! (.var 0))) (.symbol "Hello, world")
  |> mk_test run

--#eval two_hello_world_app

def three_hello_world_lc := f$ (f$ (f$ succ_lc (f$ succ_lc (f$ succ_lc zero_lc))) (λ! (.var 0))) (.symbol "Hello, world")

def test_three_hello_world : Except Error Expr := do
  let cm_e ← Expr.of_lc three_hello_world_lc
  try_step_n run 3 cm_e

--#eval test_three_hello_world

def five_hello_world_lc := f$ (f$ (f$ succ_lc (f$ succ_lc (f$ succ_lc (f$ succ_lc (f$ succ_lc zero_lc))))) (λ! (.var 0))) (.symbol "Hello, world")

def test_five_hello_world : Except Error Expr := do
  let cm_e ← Expr.of_lc five_hello_world_lc
  try_step_n run 3 cm_e

--#eval test_five_hello_world

def mk_test_hello_world_n (n max_steps : ℕ) : Except Error Expr := do
  let succ_e := List.replicate n succ_lc
    |> List.foldr (fun succ_e acc => (f$ succ_e acc)) zero_lc

  let hello_e := (f$ (f$ succ_e (λ! (.var 0))) (.symbol "Hello, world"))

  let cc ← Expr.of_lc hello_e
  try_step_n run max_steps cc

--#eval mk_test_hello_world_n 80 3

--#eval test_three_hello_world

def three_hello_world_app := f$ (f$ (f$ succ_lc (f$ succ_lc (f$ succ_lc zero_lc))) (λ! (.var 0))) (.symbol "Hello, world")
  |> mk_test run

--#eval three_hello_world_app

/-
Y = λ f (λ x.f(x x))(λ x. f(x x))
λx.f(x x) = (λ! ($f (.var 1) ($f (.var 0) (.var0))))
Y = λ! (
-/
def y_comb_lc : LcExpr DebruijnIdx :=
  let inner := (λ! (f$ (.var 1) (f$ (.var 0) (.var 0))))
  λ! (f$ inner inner)

/-
iszero = λn.n(λx.flse)tre
iszero (succ(zero)) = (succ(zero)) (λx.flse) tre
iszero zero = zero _ tre = tre
iszero = λ! (f$ (f$ (.var 0) (λ! flse)) tre)
-/
def is_zero_lc : LcExpr DebruijnIdx :=
  λ! (f$ (f$ (.var 0) (λ! flse_lc)) tre_lc)

/-
If the output is true, then we should be able to plug in
"a" and "b" and get out "a"
-/
def test_is_zero (max_steps : ℕ := 20) : Except Error Expr := do
  let tre_test := (f$ (f$ tre_lc (.symbol "a")) (.symbol "b"))
  let test := (f$ (f$ zero_lc (.symbol "a")) (.symbol "true"))
  --let is_zero_app_zero := (f$ (f$ (f$ (f$ zero_lc (.symbol "a")) tre_lc) (.symbol "a")) (.symbol "b"))
  let cc ← Expr.of_lc tre_test
  try_step_n run max_steps cc

--#eval test_is_zero

end positional

-/
