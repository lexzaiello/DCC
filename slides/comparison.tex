\documentclass{beamer}
\usepackage{fontspec}
\usepackage{minted}
\usepackage{venndiagram}
\usepackage[
  backend=biber,
  style=alphabetic,
  sorting=ynt
]{biblatex}
\addbibresource{./refs.bib}

\AtBeginSection[]{
  \begin{frame}
    \vfill
    \centering
    \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
      \usebeamerfont{title}\insertsectionhead\par%
    \end{beamercolorbox}
    \vfill
  \end{frame}
}

\setmainfont{DejaVu Serif} 
\setsansfont{DejaVu Sans}
\setmonofont{JuliaMono}[
    Scale=0.9,
    Extension = .ttf,
    UprightFont = *-Regular,
    BoldFont = *-Bold,
    ItalicFont = *-RegularItalic,
    BoldItalicFont = *-BoldItalic
]

\usemintedstyle{tango}

\newcommand{\leane}[1]{\mintinline{lean4}|#1|}
\newcommand{\dcce}[1]{\mintinline{lean4}[style=manni]|#1|}
\newcommand{\pie}[1]{\Pi_{#1}}
\newcommand{\type}[1]{\text{Type } #1}
\newcommand{\turnstile}{\vdash}
\newcommand{\sigl}[1]{\(\texttt{::[}#1\texttt{]}\)}
\newcommand{\sigle}[1]{\texttt{::[}#1\texttt{]}}

\usetheme{Madrid}

\title{Comparison of Dependent Combinators}
\author{Alexandra Aiello}
\date{\today}

\begin{document}

\frame{\titlepage}

\begin{frame}{Distinct Iterations of the Calculus}
  \begin{figure}
  \resizebox{\textwidth}{!}{%
  \begin{tabular}{ |l|p{2.5cm}|c|p{2cm}|p{2cm}| }
    \hline
    Name & Main Feature & Meta Combinators?* & Uncurried Types? & Types are Well-Typed? \\
    \hline
    \(SKM\) & Reflection & Yes & No & No \\
    \hline
    \(SK\Pi\) & \(\Pi\) Combinator & Yes & No & No \\
    \hline
    \(SK\Gamma\) & \((\Gamma, \Delta)\) registers & No & Yes & Barely. Couldn't handle random edge cases. \\
    \hline
    List Calculus & Extremely minimal kernel & No & Barely well-typed & Barely well-typed \\
    \hline
    Sigma interpretation & Sigma type is data encoding \(\Pi\) & No & No & Probably \\
    \hline
  \end{tabular}
}
\caption{*Meta combinators result in a huge tree. Each meta combinator has a type.}
\end{figure}
\end{frame}

\begin{frame}{The Ideal Dependent Combinator Calculus}
  \begin{itemize}
    \item Use \((\Gamma, \Delta)\) registers.
    \item Use \(\pi\) list pattern matching combinator to shrink the kernel. \(\pi(fx, fxs, \sigle{x, xs}) = \sigle{fx(x), fxs(xs)}\).
    \item Sigma interpretation: \(\Gamma[n]\) is a nested sigma pair. Same eval rules as in \((\Gamma, \Delta)\), but a new well-typed meaning.
    \item Potentially internalize substitution into \sigl{x, xs} sigma pairs. \sigle{x, xs} receives a ``projector'' resembling \(f\) in a list fold: \leane{(.app ::[x, f], fn) => pure (.app fn, f, x)}. Lets us omit some judgment rules.
  \end{itemize}
\end{frame}

\end{document}
