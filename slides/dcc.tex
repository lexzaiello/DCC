\documentclass{beamer}
\usepackage{fontspec}
\usepackage{minted}
\usepackage[
  backend=biber,
  style=alphabetic,
  sorting=ynt
]{biblatex}
\addbibresource{./refs.bib}

\AtBeginSection[]{
  \begin{frame}
    \vfill
    \centering
    \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
      \usebeamerfont{title}\insertsectionhead\par%
    \end{beamercolorbox}
    \vfill
  \end{frame}
}

\setmainfont{DejaVu Serif} 
\setsansfont{DejaVu Sans}
\setmonofont{JuliaMono}[
    Scale=0.9,
    Extension = .ttf,
    UprightFont = *-Regular,
    BoldFont = *-Bold,
    ItalicFont = *-RegularItalic,
    BoldItalicFont = *-BoldItalic
]

\usemintedstyle{tango}

\newcommand{\leane}[1]{\mintinline{lean4}|#1|}
\newcommand{\dcce}[1]{\mintinline{lean4}[style=manni]|#1|}
\newcommand{\pie}[1]{\Pi_{#1}}
\newcommand{\type}[1]{\text{Type } #1}
\newcommand{\turnstile}{\vdash}
\newcommand{\sigl}[1]{\(\texttt{::[}#1\texttt{]}\)}
\newcommand{\sigle}[1]{\texttt{::[}#1\texttt{]}}

\usetheme{Madrid}

\title{The Dependent Combinator Calculus}
\author{Alexandra Aiello}
\date{\today}

\begin{document}

\frame{\titlepage}

\begin{frame}{Problem Statement: The \(\Pi\)-Combinator Mismatch}
  \begin{itemize}
    \item Lambdas are curried \(\lambda x.\lambda y.M\), and so are their types \(\forall (x : \alpha), \forall (y : \beta), \ldots\).
    \item Combinators are uncurried (\(K(x, y) = x\)). Fixed number of known arguments.
    \item Past approaches treated combinator types as curried.
      \begin{itemize}
        \item Altenkirch and I used \(\Pi\) combinators, or meta combinators. Many disadvantages.
      \end{itemize}
    \item By uncurrying combiantor types, dependent types become simple, and elegant.
  \end{itemize}    
\end{frame}

\begin{frame}[fragile]{Central Thesis: Combinator-Sigma Correspondence}
  \begin{figure}
\begin{minted}[mathescape, fontsize=\small, linenos]{lean4}
def Sigma.curry {γ : ∀ a, β a → Type*}
  (f : ∀ x : Sigma β, γ x.1 x.2)
  (x : α)
  (y : β x) : γ x y := f ⟨x, y⟩

def Sigma.uncurry {γ : ∀ a, β a → Type*}
  (f : ∀ (x) (y : β x), γ x y)
  (x : Sigma β) : γ x.1 x.2 :=
  f x.1 x.2

-- in Mathlib Equiv module
def piCurry {α} {β : α → Type*} (γ : ∀ a, β a → Type*) :
    (∀ x : Σ i, β i, γ x.1 x.2) ≃ ∀ a b, γ a b := ...
\end{minted}
    \caption{Equivalence between dependent functions and sigmas in Mathlib (curry-uncurry). Sigmas carry the variable and substitution as data, whereas \(\forall\) substitution is not data.}
  \end{figure}
\end{frame}

\begin{frame}[fragile]{Central Thesis: Combinator-Sigma Correspondence}
  \begin{figure}
  \begin{minted}[mathescape, fontsize=\small, frame=lines]{lean4}
-- The usual dependent K combinator in Lean.
K (α : Type u) (β : α → Type v) (x : α) (y : β x) : α := x

-- Output of check Sigma.mk
Sigma.mk.{u, v} {α : Type u} {β : α → Type v} (fst : α)
  (snd : β fst) : Sigma β

-- Output of check Sigma.fst. This is K .. = x
Sigma.fst.{u, v} {α : Type u} {β : α → Type v}
  (self : Sigma β) : α
\end{minted}
  \caption{The dependent \(K\) combinator has the same type as \leane{Sigma.fst ∘ Sigma.mk}. Hypothesis: A function on a sigma term (e.g., projection) corresponds to a dependent combinator equation.}
\end{figure}
\end{frame}

\begin{frame}[fragile]{AST: \textit{DCC}}
\begin{minted}[mathescape, fontsize=\small, frame=lines]{lean4}
  inductive Expr where
  | app    : Expr → Expr → Expr
  | ty     : ℕ → Expr
  -- Sigmas ::[a, b]
  | cons   : Expr → Expr → Expr
  /-
    nil α x = α. Closes the loop of dependency in sigma.
    ::[α, nil α] x = α
  -/
  | nil    : Level → Expr
  /-
    Dependent and nondependent versions of K.
  -/
  | const  : Level → Level → Expr
  | const' : Level → Level → Expr
\end{minted}
Cont \ldots
\end{frame}

\begin{frame}[fragile]{AST (cont \ldots): \textit{DCC}}
\begin{minted}[mathescape, fontsize=\small, frame=lines]{lean4}
/-
    Dependent and extra nondependent versions of S.
    both' does not accept β and γ arguments.
    both' is used inside sigma types to form expressions.
    both'.{[m, n, o]} α (f : α → Type n)
      (g : α → Type o)
      (x : α) : (Type (max n o)).succ
    both is the usual S combinator.
  -/
  | both   : Level → Level → Level → Expr
  | both'  : Level → Level → Level → Expr
  | id     : Level → Expr
\end{minted}
\end{frame}

\begin{frame}[fragile]{Inference Rule: Application}
  \begin{aligned}
    \frac{\Gamma \vdash,
    \alpha : \type{u},\
    \beta : \sigle{\alpha, (\texttt{const'.{[v.succ.succ, u]}}\ \type{v.succ}\ \alpha\ \type{v})},\
    f : ::[\alpha, \beta],
    x : \alpha}{\Gamma \vdash (f\ x) : \beta\ x}
  \end{aligned}
\end{frame}

\end{document}
