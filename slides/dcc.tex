\documentclass{beamer}
\usepackage{fontspec}
\usepackage{minted}

\setmainfont{DejaVu Serif} 
\setsansfont{DejaVu Sans}
\setmonofont{JuliaMono}[
    Scale=0.9,
    Extension = .ttf,
    UprightFont = *-Regular,
    BoldFont = *-Bold,
    ItalicFont = *-RegularItalic,
    BoldItalicFont = *-BoldItalic
]

\usemintedstyle{tango}

\newcommand{\pie}[1]{\Pi_{#1}}
\newcommand{\type}[1]{\text{Type } #1}
\newcommand{\turnstile}{\vdash}
\newcommand{\sigl}[1]{\(\texttt{::[}#1\texttt{]}\)}
\newcommand{\sigle}[1]{\texttt{::[}#1\texttt{]}}

\usetheme{Madrid}

\title{The Dependent Combinator Calculus}
\author{Alexandra Aiello}
\date{\today}

\begin{document}

\frame{\titlepage}

\begin{frame}{Overview}
  \begin{itemize}
    \item The \textit{DCC} achieves dependent typing without variables by interpreting sigma types (i.e., \mintinline{lean4}|(fst : \alpha) \times (snd : \beta x)| in Lean) as a future function application.
    \item We make use of a correspondence between \(Sigma.snd\) projection and variable substitution to emulate \(\Pi\) binders
    \item This correspondence also acts as a bridge between curried functions and \(n\)-argument functions, like combinators by allowing arguments to be treated as data to be applied later.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{AST}
  \begin{minted}[mathescape, fontsize=\small, linenos]{lean4}
abbrev Level := ℕ

inductive Expr where
  | ty     : Level → Expr
   -- Cons can be partially applied, so it is a combinator
  | cons   : Expr
  | app    : Expr → Expr → Expr
   -- Nil "downgrades" a term to a type
   -- nil (α : Ty m) : α → Ty m
   -- useful for typing arguments like ∀ (α : Type), ...
  | nil    : Expr
  -- The I combinator in SK
  | id     : Level → Expr
  -- Dependent K combinator
  | const  : Level → Level → Expr
  -- Nondependent K. Closes the loop of type dependency.
  | const' : Level → Level → Expr
\end{minted}

Continued...
\end{frame}

\begin{frame}[fragile]{AST (cont \ldots)}
  \begin{minted}[mathescape, fontsize=\small, linenos]{lean4}
  inductive Expr where
  -- forms a new sigma pair from (both f g x) ::[(f x), (g x)]
  -- but does not force application of (f x) (g x)
  -- combined with snd projection results in S
  | both   : Level → Level → Level → Expr
  -- Branch on def-eq. For practical applications.
  | eq     : Level → Expr
  \end{minted}
\end{frame}

\begin{frame}[fragile]{Evaluation Rules}
  
\end{frame}

%\begin{frame}{Evaluation Rules}
%  \begin{itemize}
%    \item 
%  \end{itemize}
%\end{frame}

%\begin{frame}{Inference Rule: Function Application}
%
%  \begin{itemize}
%    
%  \end{itemize}
%  
%\end{frame}

\end{document}

