\documentclass{beamer}
\usepackage{fontspec}
\usepackage{ulem}
\usepackage{minted}
\usepackage[table]{xcolor}
\usepackage[
  backend=biber,
  style=alphabetic,
  sorting=ynt
]{biblatex}
\addbibresource{./refs.bib}

\AtBeginSection[]{
  \begin{frame}
    \vfill
    \centering
    \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
      \usebeamerfont{title}\insertsectionhead\par%
    \end{beamercolorbox}
    \vfill
  \end{frame}
}

\setmainfont{DejaVu Serif} 
\setsansfont{DejaVu Sans}
\setmonofont{JuliaMono}[
    Scale=0.9,
    Extension = .ttf,
    UprightFont = *-Regular,
    BoldFont = *-Bold,
    ItalicFont = *-RegularItalic,
    BoldItalicFont = *-BoldItalic
]

\usemintedstyle{tango}
\newminted[leancode]{lean4}{
    mathescape=false,
    fontsize=\small
  }
\newmintinline[leanw]{lean}{formatcom=\color{white}}
\newcommand{\leane}[1]{\mintinline{lean4}|#1|}
\newcommand{\dcce}[1]{\mintinline{lean4}[style=manni]|#1|}
\newcommand{\pie}[1]{\Pi_{#1}}
\newcommand{\type}[1]{\text{Type } #1}
\newcommand{\turnstile}{\vdash}
\newcommand{\sigl}[1]{\(\texttt{::[}#1\texttt{]}\)}
\newcommand{\sigle}[1]{\texttt{::[}#1\texttt{]}}

\usetheme{Madrid}

\title{Updates: Dependent Combinator Calculus}
\author{Alexandra Aiello}
\date{\today}

\begin{document}

\frame{\titlepage}

\begin{frame}{Distinct Iterations of the Calculus}
  \begin{figure}
  \resizebox{0.825\textwidth}{!}{%
  \begin{tabular}{ |p{0.1\textwidth}|p{0.23\textwidth}|p{0.23\textwidth}|p{0.23\textwidth}|p{0.2\textwidth}| }
    \hline
    Name & Main Feature & Meta Combinators?* & Uncurried Types? & Types are Well-Typed? \\
    \hline
    \(SKM\) & Reflection & Yes & No & No \\
    \hline
    \(SK\Pi\) & \(\Pi\) Combinator & Yes & No & No \\
    \hline
    \(SK\Gamma\) & \cellcolor{yellow!20}\((\Gamma, \Delta)\) registers & No & \cellcolor{yellow!20}Yes & Barely. Couldn't handle random edge cases. \\
    \hline
    List Calculus & \cellcolor{yellow!20}Extremely minimal kernel & No & Barely well-typed & Barely well-typed \\
    \hline
    Sigma interpretation & \cellcolor{yellow!20}Sigma type is data encoding \(\Pi\) & No & No & \cellcolor{yellow!20}Probably \\
    \hline
  \end{tabular}
}
\caption{*Meta combinators result in a huge tree. Each meta combinator has a type.}
\end{figure}
\end{frame}

\begin{frame}{The Ideal Dependent Combinator Calculus}
  \begin{itemize}
    \item Use \((\Gamma, \Delta)\) registers.
    \item Condense \(\pi\), \leane{next}, \leane{read} into one rule (equivalence proven \hyperlink{equivfst}{\beamergotobutton{here}}):
      \begin{itemize}
        \item \leane{IsStep.sapp : IsStep (.app ::[x, f] fn) (.app (.app fn f) x)}.
        \item Very small kernel!
      \end{itemize}
    \item Pair interpretation: \(\Gamma[n]\) is a nested pair. Same eval rules as in \((\Gamma, \Delta)\), but a new well-typed meaning.
    \item Potentially internalize projection into \sigl{x, xs} sigma pairs (see .
      \begin{itemize}
        \item \leane{(.app ::[x, f], fn) => pure (.app fn, f, x)}
        \item Fewer inference rules, since \sigl{x, f} is already a special case.
      \end{itemize}
    \item \texttt{nil} combinator: downgrades a term to a type.
      \begin{itemize}
        \item Useful for arguments like \(\alpha : \type{n}\)
      \end{itemize}
    \item Core calculus is the typical \(SK\) combinators
  \end{itemize}
\end{frame}

\begin{frame}{Ideal Inference Rule: Application}
  \begin{equation}
    \frac{
      \Gamma \vdash f : \sigle{\sigle{t_{in}, t_{out}}, \Delta},
      x : \alpha,
      (t_{in}\ \sigle{x, \delta}) \mapsto \alpha
    }{\Gamma \vdash (f\ x) : \sigle{t_{out}, \sigle{x, \Delta}}}
  \end{equation}
\end{frame}

\section{Research Questions}

\begin{frame}{TODOs}
  \begin{itemize}
    \item \soute{Should we internalize \(\pi\) projection in \sigl{a, b}, or should we have \sigl{fst, snd} combinators?} \textbf{Yes!}
      \begin{itemize}
        \item \sout{Can we derive \leane{fst}?} \textbf{Yes!}
        \item \sout{Can we derive \leane{snd}?} \textbf{Yes!}
        \item \sout{Can we fully emulate the old \(\pi\) combinator with a projector agrument?} \textbf{Yes!}
      \end{itemize}
    \item Can we derive application from \(\pi\) projection?
    \item Can we derive \(S\) from both + \(\pi(id)\)?
    \item Choose between \leane{fst} + \leane{snd} or \(\pi\) list projection combinator.
      \begin{itemize}
        \item Intuition says \leane{fst} and \leane{snd}, since they would have simpler types.
      \end{itemize}
      \item Should assertions get access to \sigl{x} or \sigl{x, \alpha}? Should work through some examples to compare.
    \end{itemize}
\end{frame}

\begin{frame}{Research Questions AST}
  \begin{figure}
  \begin{leancode}
inductive Expr where
  | app : Expr → Expr → Expr
  | cons : Expr → Expr → Expr
  | π : Expr
  | fst : Expr | snd : Expr
  | both : Expr
  | const : Expr | const' : Expr
  | id : Expr | nil : Expr | ty : Expr
\end{leancode}
\caption{I have omitted universe levels for our research question proofs.}
\end{figure}
\end{frame}

\begin{frame}{Research Questions Multi-Step Relation}
\begin{leancode}
inductive IsStepStar { rel : Expr → Expr → Prop } : Expr → Expr → Prop
  | refl  : IsStepStar e e
  | trans : rel e₁ e₂
    → IsStepStar e₂ e₃
    → IsStepStar e₁ e₃
\end{leancode}
\end{frame}

\subsection{\leanw{fst} and \leanw{snd} can be condensed into one rule}

\begin{frame}{Projection Derivation \leanw{IsStep}}
  \begin{leancode}
inductive IsStep : Expr → Expr → Prop
  | sapp   : IsStep ($ ::[x, f], fn) ($ fn, f, x)
  | fst    : IsStep ($ fst, _α, _β, fn, ::[x, f]) ($ fn, x)
  | snd    : IsStep ($ snd, _α, _β, fn, ::[x, f]) ($ fn, f, x)
  | nil    : IsStep ($ nil, α, x) α
  | id     : IsStep ($ Expr.id, _α, x) x
  | const' : IsStep ($ const', _α, _β, x, y) x
  | left   : IsStep f f'
    → IsStep ($ f, x) ($ f', x)
  | right  : IsStep x x'
    → IsStep ($ f, x) ($ f, x')
  \end{leancode}
\end{frame}

\begin{frame}[label=equivfst, fragile]{Deriving the Explicit \leanw{fst} Combinator}
  \begin{leancode}
/-
  fst α β fn ::[head, tail] = fn head =
    ::[head, tail] fn =* fn head
-/
theorem fst_der (head tail fn : Expr) : IsStep
  ($ fst, _α, _β, fn, ::[head, tail]) ($ fn, head) ↔
  (@IsStepStar IsStep) ($ ::[head, tail],
    ($ const', ::[β, ($ nil, β)], α, fn)) ($ fn, head) := by
  constructor
  intro h_step; cases h_step
  apply IsStepStar.trans; apply IsStep.sapp
  apply IsStepStar.trans; apply IsStep.left
  apply IsStep.const'; apply IsStepStar.refl
  intro h_step; cases h_step
  case mpr.trans e₂ h_step h_trans =>
    cases h_trans; apply IsStep.fst
    apply IsStep.fst
  \end{leancode}
\end{frame}

\begin{frame}[fragile]{Deriving the Explicit \leanw{snd} Combinator}
  \begin{leancode}
/-
  snd α β fn ::[head, tail] = ::[head, tail] fn
  = fn tail head
-/
theorem snd_der (head tail fn : Expr) : IsStep
  ($ snd, _α, _β, fn, ::[head, tail]) ($ fn, tail, head) ↔
  (@IsStepStar IsStep) ($ ::[head, tail], fn) ($ fn, tail, head) := by
  constructor
  intro h_step; cases h_step
  apply IsStepStar.trans; apply IsStep.sapp
  apply IsStepStar.refl
  case mp.right a =>
    cases a
  intro h_step
  cases h_step
  apply IsStep.snd
  \end{leancode}
\end{frame}

\subsection{Sigma projection is equivalent to application}

\begin{frame}[fragile]{All Apps have corresponding Proj.}
  \begin{leancode}
theorem app_imp_proj (t_f f x : Expr) : (@IsStepStar IsStep) ($ f, x) e' →
  (@IsStepStar IsStep) ($ ::[x, f], ($ id, t_f)) e' := by
  intro h_step
  cases h_step
  apply IsStepStar.trans; apply IsStep.sapp
  apply IsStepStar.trans; apply IsStep.left
  apply IsStep.id; apply IsStepStar.refl
  apply IsStepStar.trans; apply IsStep.sapp
  apply IsStepStar.trans; apply IsStep.left
  apply IsStep.id; apply IsStepStar.trans
  repeat assumption
  \end{leancode}
\end{frame}

\begin{frame}[fragile]{Apps are \(=_{\beta}\) Sigma Projection}
  \begin{leancode}
theorem apps_are_proj (t_f f x : Expr) : (@IsBetaEq IsStep) ($ f, x) ($ ::[x, f], ($ id, t_f)) := by
  apply IsBetaEq.symm; apply IsBetaEq.trans
  apply IsBetaEq.rel; apply IsStep.sapp
  apply IsBetaEq.trans; apply IsBetaEq.rel
  apply IsStep.left; apply IsStep.id
  apply IsBetaEq.refl
  \end{leancode}
\end{frame}

\end{document}
