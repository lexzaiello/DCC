import Mathlib.Data.Nat.Notation

import Cm.Pi.Ast
import Cm.Pi.Eval
import Cm.Pi.Util
import Cm.Pi.Curry

open Std (Format)
open Std (ToFormat)
open Std.ToFormat (format)

open Expr

abbrev DebruijnIdx := ℕ

/-
A lambda calculus expression where variables are represented by
the type α.
-/
inductive LcExpr (α : Type) where
  | app : LcExpr α
    → LcExpr α
    → LcExpr α
  | lam : LcExpr α
    → LcExpr α
  | var : α → LcExpr α
  | symbol : String -- our machine has these
    → LcExpr α

def LcExpr.fmt : (LcExpr DebruijnIdx) → Format
  | .app f x => "f$ " ++ Format.paren (.group <| .nest 2 <| f.fmt ++ Format.line ++ x.fmt)
  | .var n => s!".var {n}"
  | .lam body => "(λ! " ++ .paren body.fmt ++ ")"
  | .symbol s => s!"(symbol {s})"

instance LcExpr.instToFormat : ToFormat (LcExpr DebruijnIdx) where
  format := LcExpr.fmt

instance LcExpr.instToString : ToString (LcExpr DebruijnIdx) where
  toString := toString ∘ format

notation "λ!" => LcExpr.lam
notation "f$" => LcExpr.app
notation:max "#" => @LcExpr.var DebruijnIdx

/-
We should be able to detect the arity of expressions before compiling.
This is just the maximum lambda depth.

λ 0 => this should always compile to id

λ ($f 0 0) => this should compile to (:: both (:: (quote apply) (:: both id id)))

λ 1 => this is a completely free variable. should compile to (quote const)
λ 2 => this is a completely free variable. it should do the sasme substitution
that λ λ 1 does. only makes sense within a 

λ λ 0 => this should compile to (quote (quote id))

λ λ 1 => this should compile to (:: both (:: (quote const) id))

argument passing format:
(:: both (:: (quote apply) (:: both T[x] T[x])))

Why do free variables matter? Why can't we just pass eagerly call the inner lambda if we have nested lambdas?

λ 1 => (quote const)
λ 2 => (quote (quote const))

λ λ 1 => (:: both (:: (quote const) id))

we could also just decrement all free variables as we traverse under lambdas.
λ λ 1 => don't decrement 1, since it is BOUND (:: both (:: (quote const) id))

λ λ 2 => decrement 1,


-/

def mk_n_const (n : ℕ) (inner_e : Expr) : Expr := (List.replicate n Expr.const).foldr (fun _e acc => (quote acc)) inner_e

/-
Note that expressions generated by abstract are inert.
You must ::apply them with argumnets.

If the body of a lambda contains only bound expressions, we should just const it.

λ λ 1 => (:: const id)
-/

def is_bound (var depth : ℕ) : Bool := var < depth

def all_bound (depth : ℕ) : LcExpr DebruijnIdx → Bool
  | .var n => is_bound n depth
  | .lam b => all_bound depth.succ b
  | .symbol _s => true
  | .app f x => all_bound depth f && all_bound depth x

def all_free (depth : ℕ) : LcExpr DebruijnIdx → Bool
  | .var n => ¬ (is_bound n depth)
  | .lam b => all_free depth.succ b
  | .symbol _s => true
  | .app f x => all_free depth f && all_free depth x

def quot_if_free (depth : ℕ) (original : LcExpr DebruijnIdx) (e : Expr) : Expr :=
  if all_free depth original then
      (:: both (:: (quote const) e))
  else e

def quot_if_bound (depth : ℕ) (original : LcExpr DebruijnIdx) (e : Expr) : Expr :=
  if all_bound depth original then
      (:: both (:: (quote const) e))
  else e

def decr_all_vars : LcExpr DebruijnIdx → LcExpr DebruijnIdx
  | .var n => .var (n - 1)
  | .app f x => .app (decr_all_vars f) (decr_all_vars x)
  | .lam bdy => .lam (decr_all_vars bdy)
  | .symbol s => .symbol s

/-
Idea:
λ λ n => select nth items from context. what to do if we are a free variable?
de bruijn index zero selects the last element in the context
π ((const nil) (π (const nil) (π (const nil) id)
we will put arguments in the original order.

store arguments in cons order?
so de bruijn index zero is just the head.
-/

def get_head : Expr := :: π (:: id (:: const nil))

/-
TODO: we can probably make cc_variable more efficient for apps.
map_variable.
-/
def cc_variable : DebruijnIdx → Expr
  | .zero => :: π (:: id nil)
  | .succ n =>
    (:: π (:: nil (cc_variable n)))

abbrev VariableMap := Expr → Expr

/-
Map indices
- last operation in the program is a (:: π (:: id (:: const nil)))
- this will keep the list intact except the nth argument
-/
def map_variable (n : DebruijnIdx) : VariableMap :=
  match n with
  | .zero => (fun fn => :: π (:: fn id))
  | .succ n => (fun fn => :: π (:: id (map_variable n fn)))

/-
Arguments get pushed in in reverse de bruijn order.
one f x has the context (:: x f)

so we map the elements like this:
map_variable (:: (:: both (:: const apply) id)) 1

one := λ! (λ! (f$ (# 1) (# 0)))

we translate this to:

Our functions are just π expressions.

one := id

Final operation in the program is (:: apply (:: ops ctx))
one id (symbol "hi") => (:: apply (:: id (symbol "hi")))

succ n f x = f (n f x)

first operation we need to do is to convert all arguments to lists.
nested applications are fine.

map variable is fine.

λ x.x => map_variable ?

So we're composing a bunch of map_variable calls.

Variable maps map on the context.
Symbol injects a new value into the context.

nested lambdas are no-ops, since the de bruijn indices tell us what we need to do.
λ λ 0

Applications inside lambdas?
(λx λ y => (x y)) (:: (symbol "a") (symbol "b"))

This is composition of variable maps.

-/

def Expr.cons_ctx : Expr → List Expr → List Expr
  | :: x nil, l => List.cons x l
  | x, l => List.cons x l

def Expr.from_list : List Expr → Expr
  | .nil => nil
  | .cons x xs => (:: x (Expr.from_list xs))

def abstract'' : LcExpr DebruijnIdx → VariableMap
  | .var n => map_variable n
  | .symbol s => Expr.cons (.symbol s)
  | .lam bdy => abstract'' bdy
  | .app f x => (abstract'' f) ∘ (abstract'' x)

def terminal_op : Expr := :: π (:: id nil)
def terminal_map (ctx : Expr) : Expr := :: apply (:: terminal_op ctx)

def Expr.of_lc_ctx' (ctx : List Expr) : LcExpr DebruijnIdx → Except Error Expr
  | .app f x => do
    let x' ← Expr.of_lc_ctx' [] x -- x does not receive the context
    let ctx' := Expr.cons_ctx x' ctx
    let f' ← Expr.of_lc_ctx' ctx' f
    let out := pure <| (:: apply (:: f' (Expr.from_list ctx')))
    out
  | .lam b => pure <| abstract'' b id
  | .symbol s => pure <| (:: (.symbol s) nil)
  | .var _ => .error <| .var_in_output

def Expr.of_lc'' : LcExpr DebruijnIdx → Except Error Expr := (Expr.of_lc_ctx' [])
  >=> (pure ∘ terminal_map)

def test_id_whack : Except Error Expr := do
  let id' := λ! (# 0)
  let my_data := .symbol "hi"
  let my_app := (f$ id' my_data)
  let cc ← Expr.of_lc'' my_app
  dbg_trace cc
  do_step run cc

#eval test_id_whack

def abstract' : LcExpr DebruijnIdx → Except Error Expr
  | .var n => pure <| cc_variable n
  | .symbol s => pure <| :: const (symbol s)
  | .lam b => do
    -- λ (λ 0) we just substitute our context in
    -- this is actually a no-op
    -- nested lambda requires deferring apply
    -- until we have all the arguments we're expecting
    pure <| (:: both (:: (quote apply) (:: both (:: (quote (← abstract' b)) id))))
  | .app f x => do
    /-
      Future application. λf (λx f x). To do this, we use both. Then, we apply.
    -/
    let f' ← abstract' f
    let x' ← abstract' x
    pure <| (:: both (:: (quote apply) (:: f' x')))

/-
We store arguments in an order that matches our debruijn indices.
f a b - (:: a (:: b nil))

(λ λ 0) a b -> 0 corrresponds to b, not a, so we store lazily and then fold into a context.
-/
def Expr.of_lc_ctx (ctx : List Expr) : LcExpr DebruijnIdx → Except Error Expr
  | .lam b => abstract' b
  | .symbol s => pure <| .symbol s
  | .var _ => .error <| .var_in_output
  | .app f x => do
    let x' ← Expr.of_lc_ctx [] x -- x does not receive the context, since it is associated on the right.
    let ctx' := List.cons x' ctx
    let f' ← Expr.of_lc_ctx ctx' f -- f does not receive the context either

    dbg_trace ctx'

    pure <| (:: apply (:: f' (Expr.from_list ctx'.reverse)))

def Expr.of_lc' : LcExpr DebruijnIdx → Except Error Expr := Expr.of_lc_ctx []

namespace positional_tests

def mk_test (lam_e : LcExpr DebruijnIdx) (step_with : Expr → Except Error Expr := run) : Except Error Expr := do
  let cm_e ← Expr.of_lc' lam_e
  do_step step_with cm_e

def test_id : Except Error Expr :=
  mk_test (f$ (λ! (# 0)) (.symbol "hi"))

#eval test_id

def test_second_arg : Except Error Expr :=
  mk_test (f$ (f$ (λ! (λ! (# 0))) (.symbol "a")) (.symbol "hi"))


#eval test_second_arg

end positional_tests

/-mutual
/-
Need to do the same "substitution" thing at the top level
-/
def abstract (depth : ℕ) : LcExpr DebruijnIdx → Except Error Expr
  | .var n =>
    if is_bound n depth then
      -- if this variable is bound, then
      -- λ (λ 0) => (const (const id))
      -- we are skipping variables here
      pure <| mk_n_const (depth - 1 - n) id
    else
      -- this is the free variable case
      -- here, we are reaching backwards.
      pure <| mk_n_const (n - depth) id -- depth is handled in lambda nesting case
  | .symbol s => pure <| :: const (symbol s)
  | .lam b =>
    -- If this is a constant value, compile the inside as usual, then const it
    if all_bound 0 (.lam b) then
      quote <$> Expr.of_lc (.lam b)
    else
      /-
        If all inner lambdas are free, then we should const the result after running it
      -/
      abstract depth.succ b
        >>= (pure ∘ (quot_if_free depth b ·))
  | .app f x => do
    -- 1 here to treat f and x as if they were under a lambda
    -- since we are applying x to f, t_f depth.succ
    /-
      if f or x are all bound, then we can just Expr.of_lc them
    -/
    /-match all_bound 0 f, all_bound 0 x with
    | true, true => -- if both elements are bound, then they are constant values. so just apply them. but, since the left is being applied, depth 1
      pure <| quote (:: apply (:: (← Expr.of_lc f) (← Expr.of_lc x)))
    | false, true =>
      pure <| (:: both (:: (quote apply) (:: both (:: (← abstract depth f) (quote (← Expr.of_lc x))))))
    | true, false =>
      pure <| (:: both (:: (quote apply) (:: both (:: (quote (← Expr.of_lc f)) (← abstract depth x)))))
    | false, false =>
      pure <| (:: both (:: (quote apply) (:: both (:: (← abstract depth f) (← abstract depth x)))))-/
    -- treat f and x as if they were lambdas. similar to S transformation. S (λ f) (λ x)
    --dbg_trace s!"{f}: {abstract 1 f} {x}: {abstract 1 x}"
    -- both f and x receive the context so far
    let t_f ← abstract depth f
    let t_x ← abstract depth x

    pure <| (:: both (:: t_f t_x))

def Expr.of_lc : LcExpr DebruijnIdx → Except Error Expr
  | .lam b =>
    abstract 1 b
  | .app f x => do
    let t_f ← Expr.of_lc f
    let t_x ← Expr.of_lc x
    pure <| (:: apply (:: t_f t_x))
  | .symbol s => pure <| symbol s
  | _v => .error <| .var_in_output

end

-- λ 0 => id
#eval Expr.of_lc (f$ (λ! (.var 0)) (.symbol "hi"))
  >>= do_step run

#eval Expr.of_lc (f$ (f$ (λ! (λ! (.var 0))) (.symbol "discard")) (.symbol "hi"))
  >>= do_step run

#eval Expr.of_lc (f$ (f$ (λ! (λ! (.var 1))) (.symbol "hi")) (.symbol "discard"))
  >>= do_step run

def mk_test (lam_e : LcExpr DebruijnIdx) (step_with : Expr → Except Error Expr := run) : Except Error Expr := do
  let cm_e ← Expr.of_lc lam_e
  do_step step_with cm_e

def tre_lc : LcExpr DebruijnIdx := λ! (λ! (# 1))

-- constant
#eval mk_test (f$ (f$ (f$ (λ! tre_lc) (.symbol "discard")) (.symbol "hello world")) (.symbol "discard"))

def flse_lc : LcExpr DebruijnIdx := λ! (λ! (# 0))

def example_tre := mk_test (f$ (f$ tre_lc (.symbol "a")) (.symbol "b")) (try_step_n run 1)
def example_flse := mk_test (f$ (f$ flse_lc (.symbol "a")) (.symbol "b"))

#eval example_tre
#eval example_flse

def id' := λ! (# 0)

def example_tre_app_i := mk_test (f$ (f$ (f$ tre_lc id') (.symbol "discard")) (.symbol "hello world")) (try_step_n run 1)

#eval example_tre_app_i

def one := λ! (λ! (f$ (# 1) (# 0)))
#eval Expr.of_lc one -- :: both (:: (:: const apply) (:: both (:: id id))). there should be another const

#eval (f$ (f$ one (.symbol "f")) (.symbol "x")) |> mk_test

def zero_lc := λ! (λ! (# 0))

def succ_lc := λ! (λ! (λ! (f$ (# 1) (f$ (f$ (# 2) (# 1)) (# 0)))))

def simple_inner_app := mk_test (f$ (λ! (f$ (# 0) (# 0))) (.symbol "hi"))

#eval simple_inner_app

def example_do_id := mk_test (f$ (f$ one id') (.symbol "hello world"))

#eval example_do_id

def example_zero := mk_test (f$ (f$ zero_lc (.symbol "discard")) (.symbol "hello world"))

#eval example_zero

def mk_test_hello_world_n (n max_steps : ℕ) : Except Error Expr := do
  let succ_e := List.replicate n succ_lc
    |> List.foldr (fun succ_e acc => (f$ succ_e acc)) zero_lc

  let hello_e := (f$ (f$ succ_e id') (.symbol "Hello, world"))

  let cc ← Expr.of_lc hello_e
  try_step_n run max_steps cc

#eval mk_test_hello_world_n 1 100
#eval mk_test_hello_world_n 2 100

/-
iszero = λn.n(λx.flse)tre
iszero (succ(zero)) = (succ(zero)) (λx.flse) tre
iszero zero = zero _ tre = tre
iszero = λ! (f$ (f$ (.var 0) (λ! flse)) tre)
-/
def is_zero_lc : LcExpr DebruijnIdx :=
  λ! (f$ (f$ (# 0) (λ! flse_lc)) tre_lc)

#eval Expr.of_lc flse_lc -- false is :: const id
#eval Expr.of_lc one -- :: both (:: (:: const apply) (:: both (:: id id))). there should be another const
#eval mk_test (f$ is_zero_lc one) -- true is giving us (:: const (:: const id)), so one should be applying tre which should give us (:: const id)
#eval (do pure <| (← Expr.of_lc (λ! flse_lc)) == (← mk_test (f$ is_zero_lc tre_lc)))

/-
is_zero zero = true
is_zero zero a b = "a"
-/

def test_zero_app_flse_tre : Except Error Bool := do
  pure <| (← mk_test (f$ (f$ zero_lc flse_lc) tre_lc)) == (← Expr.of_lc tre_lc)

#eval test_zero_app_flse_tre

def test_is_zero_zero_tre : Except Error Bool := do
  pure <| (← mk_test (f$ is_zero_lc zero_lc)) == (← Expr.of_lc tre_lc)

#eval tre_lc |> Expr.of_lc

#eval mk_test (f$ is_zero_lc zero_lc)
#eval mk_test (f$ is_zero_lc one)
#eval test_is_zero_zero_tre

def test_is_zero_zero : Except Error Expr :=
  mk_test (f$ (f$ (f$ is_zero_lc zero_lc) (.symbol "hello world")) (.symbol "discard")) (try_step_n run 1)

def test_is_zero_one : Except Error Expr :=
  mk_test (f$ is_zero_lc one)

def test_cons_flse : Except Error Bool := do
  pure <| (← mk_test (f$ (λ! flse_lc) (.symbol "discard"))) == (← Expr.of_lc flse_lc)

#eval test_is_zero_one

def test_is_one_one : Except Error Expr :=
  mk_test (f$ (f$ (f$ is_zero_lc one) (.symbol "hello world")) (.symbol "discard"))

#eval test_is_zero_zero
#eval test_is_one_one
-/
