\documentclass{beamer}
\usepackage{fontspec}
\usepackage{minted}
\usepackage[table]{xcolor}
\usepackage[
  backend=biber,
  style=alphabetic,
  sorting=ynt
]{biblatex}
\addbibresource{./refs.bib}

\AtBeginSection[]{
  \begin{frame}
    \vfill
    \centering
    \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
      \usebeamerfont{title}\insertsectionhead\par%
    \end{beamercolorbox}
    \vfill
  \end{frame}
}

\setmainfont{DejaVu Serif} 
\setsansfont{DejaVu Sans}
\setmonofont{JuliaMono}[
    Scale=0.9,
    Extension = .ttf,
    UprightFont = *-Regular,
    BoldFont = *-Bold,
    ItalicFont = *-RegularItalic,
    BoldItalicFont = *-BoldItalic
]

\usemintedstyle{tango}

\newcommand{\leane}[1]{\mintinline{lean4}|#1|}
\newcommand{\dcce}[1]{\mintinline{lean4}[style=manni]|#1|}
\newcommand{\pie}[1]{\Pi_{#1}}
\newcommand{\type}[1]{\text{Type } #1}
\newcommand{\turnstile}{\vdash}
\newcommand{\sigl}[1]{\(\texttt{::[}#1\texttt{]}\)}
\newcommand{\sigle}[1]{\texttt{::[}#1\texttt{]}}

\usetheme{Madrid}

\title{Updates: The Dependent Combinator Calculus}
\author{Alexandra Aiello}
\date{\today}

\begin{document}

\frame{\titlepage}

\begin{frame}{Distinct Iterations of the Calculus}
  \begin{figure}
  \resizebox{0.825\textwidth}{!}{%
  \begin{tabular}{ |l|p{2.5cm}|p{1cm}|p{2cm}|p{0.2\textwidth}| }
    \hline
    Name & Main Feature & Meta Combinators?* & Uncurried Types? & Types are Well-Typed? \\
    \hline
    \(SKM\) & Reflection & Yes & No & No \\
    \hline
    \(SK\Pi\) & \(\Pi\) Combinator & Yes & No & No \\
    \hline
    \(SK\Gamma\) & \cellcolor{yellow!20}\((\Gamma, \Delta)\) registers & No & \cellcolor{yellow!20}Yes & Barely. Couldn't handle random edge cases. \\
    \hline
    List Calculus & \cellcolor{yellow!20}Extremely minimal kernel & No & Barely well-typed & Barely well-typed \\
    \hline
    Sigma interpretation & \cellcolor{yellow!20}Sigma type is data encoding \(\Pi\) & No & No & \cellcolor{yellow!20}Probably \\
    \hline
  \end{tabular}
}
\caption{*Meta combinators result in a huge tree. Each meta combinator has a type.}
\end{figure}
\end{frame}

\begin{frame}{The Ideal Dependent Combinator Calculus}
  \begin{itemize}
    \item Use \((\Gamma, \Delta)\) registers.
    \item Use \(\pi\) list pattern matching combinator to shrink the kernel.
      \begin{itemize}
        \item \(\pi(fx, fxs, \sigle{x, xs}) = \sigle{fx(x), fxs(xs)}\).
      \end{itemize}
    \item Sigma interpretation: \(\Gamma[n]\) is a nested sigma pair. Same eval rules as in \((\Gamma, \Delta)\), but a new well-typed meaning.
    \item Potentially internalize projection into \sigl{x, xs} sigma pairs.
      \begin{itemize}
        \item \leane{(.app ::[x, f], fn) => pure (.app fn, f, x)}
        \item Fewer inference rules, since \sigl{x, f} is already a special case.
      \end{itemize}
    \item \texttt{nil} combinator: downgrades a term to a type.
      \begin{itemize}
        \item Useful for arguments like \(\alpha : \type{n}\)
      \end{itemize}
  \end{itemize}
\end{frame}



\end{document}
