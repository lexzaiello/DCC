\input{./papers/template2.tex}
\usepackage[margin=0.75in]{geometry}
\usepackage{fitch}
\usepackage{bbm}
\usepackage{stmaryrd}
\usepackage{hyperref}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{rsfso}
\usepackage{graphicx}
\usepackage[
  backend=biber,
  style=alphabetic,
  sorting=ynt
]{biblatex}
\addbibresource{./refs.bib}


\author{Alexandra Aiello}
\date{December 19, 2025}
\title{The Dependent Arithmetic Machine}

\begin{document}

This is the type of a sigma \sigl{x, f}. Pairs are created with cons (\texttt{::}).
I use the notation \sigl{x_{1}, \cdots x_{n}} to denote \sigl{x_{1}, \text{\sigl{x_{2}, \cdots}}}.
Sigmas can be nested, and cons can be partially applied.
However, this means that type-checking cons is a special case, and doesn't follow directly from the general application rule.
I think this is reasonable, since it is so primitive.

Sigmas internalize the notion of projection by accepting a ``projector'' (\(\pi\)) function, which corresponds to function application where \(\pi = \text{id}\).
As such, there are no dedicated \texttt{fst} or \texttt{snd} combinators.

\begin{equation}
  \frac{
    \Gamma \vdash, (\alpha : \type{m}), (\beta : \type{n}), (x : \alpha), (y : \beta)
  }{
    \sigl{\alpha, \beta} : 
  }
\end{equation}

These are the types of the core DCC combinators.

Note that I am denoting types like \(\forall (x : \alpha), \beta(x)\) in point-free notation as \(\beta\), since
there are no \(\Pi\) binders in the DCC. This is explained more in the application inference rule.

I am using standard \(\Pi\) and \(\times\) notation here for legibility, and since I have not yet completed all the DCC tyeps in the latest, most sound version. Later in this overview, I outline the challenges I encountered, and the progress I have made towards finishing them.

\begin{equation}
\frac{}{
  \text{id}(m) : \Pi (\alpha : \type{m}) (x : \alpha), \alpha
}\\
\end{equation}

\begin{equation}
\frac{}{
  \text{nil}(m) : \Pi (\alpha : \type{m}) (x : \alpha), \type{m}
}\\
\end{equation}

\begin{equation}
\frac{}{
  \text{const'}(m,  n) : \Pi (\alpha : \type{m}) (\beta : \type{n}) (x : \alpha) (y : \beta), \alpha
}\\
\end{equation}

\begin{equation}
\frac{}{
  \text{const}(m,  n) : \Pi (\alpha : \type{m}) (\beta : \alpha \rightarrow \type{n}) (x : \alpha) (y : \beta\ x), \alpha
}\\\\
\end{equation}

\newpage

Note that this rule for both uses the point-free notation mentioned above. The judgment \(f : \beta\) is to denote \(\forall (x : \alpha), \beta(x)\). This is because our equivalent of \(\Pi\) types can be applied, unlike in the CoC.

\begin{equation}
  \frac{}{
    \text{both}(m, n, o) : \Pi (\alpha : \type{m}) (\beta : \alpha \rightarrow \type{n}) (\gamma : \alpha \rightarrow \type{o}) (f : \beta) (g : \gamma) (x : \alpha), (\beta(x) \times \gamma(x))
  }
\end{equation}

\begin{equation}
  \frac{}{
    \type{n} : \type{n + 1}
  }
\end{equation}

\begin{equation}
  \frac{}{
    
  }
\end{equation}

What's left?

\begin{itemize}
  \item{cons}
  \item{app}
  \item{eq, but if I don't get to it, that's fine}
\end{itemize}

\end{document}
