\input{./papers/template2.tex}
\usepackage[margin=0.75in]{geometry}
\usepackage{fitch}
\usepackage{bbm}
\usepackage{stmaryrd}
\usepackage{hyperref}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{rsfso}
\usepackage{graphicx}
\usepackage[
  backend=biber,
  style=alphabetic,
  sorting=ynt
]{biblatex}
\addbibresource{./refs.bib}


\author{Alexandra Aiello}
\date{December 19, 2025}
\title{The Dependent Arithmetic Machine}

\begin{document}

\section{Sigma Types}

\begin{itemize}
  \item{Sigmas are created with cons (\texttt{::})}
  \item{Notation: \sigl{x_{1}, \cdots x_{n}} denotes \sigl{x_{1}, \text{\sigl{x_{2}, \cdots}}}.}
  \item{In Lean, \texttt{::[x, f]} is represented as \texttt{.app (.cons x) f}.}
  \item{Sigmas can be nested.}
  \item{Cons can be partially applied. This requires a special case for infer.}
\end{itemize}

There are no explicit \texttt{fst} and \texttt{snd} combinators:

\begin{itemize}
  \item{\sigl{x, f} accepts a ``projector'' (\(\pi\)).}
  \item{\(\sigle{x, f}(\pi) \mapsto \texttt{.app (.app \(\pi\) f) x}\)}
  \item{\(\texttt{fst}(s) \approx s (\texttt{const'} \alpha \beta)\)}
  \item{The second element \(f\) in \texttt{::[x, f]} does not necessarily depend on \(x\). How it depends on \(x\) is determined by the projector \(\pi\).}
\end{itemize}

\subsection{Sigma Types Emulate Substitution}

Sigma types allow expressions to be stored and manipulated as list-like data.

%\subsection{Sigma Terms vs. Sigma Types}
%
%Sigmas are used to emulate contexts as in dependent type theory with variables.
%Projection on sigmas emulates substitution.
%
%The type \(\type{m} \rightarrow \type{n}\) corresponds to the sigma:
%
%%\begin{equation}
%  
%%\end{equation}
%
%In the application \(id(\sigle{a, b}, (x : \sigle{a, b}))\), the sigma is a type. Specifically, it is the type of \(x\).
%However, in the application \(\sigle{x, f}(\text{id})\), a beta-reduction occurs, so it is a term.
%
%So, I consider \sigl{a, b} to refer to a type.
%
%\begin{equation}
%  \frac{\Gamm \vdash, (a : \type{n}), (b : \type{m})}{
%    \Gamma \vdash, \esigl{a, b} : \type{\texttt{max}(n, m) + 1}
%   }
%\end{equation}
%
%However, the projection \(\sigle{a, b}(\pi)\) is judged as:
%
%\begin{equation}
%  \frac{
%    \Gamma \vdash, (\alpha : \type{m}), (\beta : \type{n}), (a : \alpha), (b : \beta)
%  }{
%    \sigle{\alpha, \beta} : 
%  }
%\end{equation}

\section{Type Type}

Functions are always typed with \sigl{x, f} expressions. So they correspond to arrow types.
However, they also do reduction. My intuition is that the \sigl{x, f} is both a term and a type, and that this should be inferrable from context.

For example, if a user wanted to reduce \(\sigle{x, f} \pi\), it ought to be a term, but if it's used where a type expected, it is a type.

\begin{itemize}
  \item{\sigl{x, f} : \text{Type}}
\end{itemize}

\begin{equation}
  \frac{}{
    \type{n} : \type{n + 1}
  }
\end{equation}

\section{SK-like Combinators}

These are the types of the core DCC combinators.

Note that I am denoting types like \(\forall (x : \alpha), \beta(x)\) in point-free notation as \(\beta\), since
there are no \(\Pi\) binders in the DCC. This is explained more in the application inference rule.

I am using standard \(\Pi\) and \(\times\) notation here for legibility, and since I have not yet completed all the DCC tyeps in the latest, most sound version. Later in this overview, I outline the challenges I encountered, and the progress I have made towards finishing them.

\begin{equation}
\frac{}{
  \text{id}(m) : \Pi (\alpha : \type{m}) (x : \alpha), \alpha
}\\
\end{equation}

\begin{equation}
\frac{}{
  \text{nil}(m) : \Pi (\alpha : \type{m}) (x : \alpha), \type{m}
}\\
\end{equation}

\begin{equation}
\frac{}{
  \text{const'}(m,  n) : \Pi (\alpha : \type{m}) (\beta : \type{n}) (x : \alpha) (y : \beta), \alpha
}\\
\end{equation}

\begin{equation}
\frac{}{
  \text{const}(m,  n) : \Pi (\alpha : \type{m}) (\beta : \alpha \rightarrow \type{n}) (x : \alpha) (y : \beta\ x), \alpha
}\\\\
\end{equation}

\newpage

Note that this rule for both uses the point-free notation mentioned above. The judgment \(f : \beta\) is to denote \(\forall (x : \alpha), \beta(x)\). This is because our equivalent of \(\Pi\) types can be applied, unlike in the CoC.

\begin{equation}
  \frac{}{
    \text{both}(m, n, o) : \Pi (\alpha : \type{m}) (\beta : \alpha \rightarrow \type{n}) (\gamma : \alpha \rightarrow \type{o}) (f : \beta) (g : \gamma) (x : \alpha), (\beta(x) \times \gamma(x))
  }
\end{equation}

What's left?

\begin{itemize}
  \item{cons}
  \item{app}
  \item{eq, but if I don't get to it, that's fine}
\end{itemize}

\end{document}
